
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Interactive UX Roles Table</title>
  <style>
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f4f6f8;
      margin: 0;
      padding: 20px;
    }
    .product-selector {
      margin-bottom: 20px;
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .product-selector h3 {
      margin: 0 0 10px 0;
      color: #2c3e50;
    }
    .product-buttons {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .product-btn {
      padding: 8px 16px;
      border: 2px solid #3498db;
      background: white;
      color: #3498db;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.9em;
    }
    .product-btn:hover {
      background: #3498db;
      color: white;
    }
    .product-btn.active {
      background: #3498db;
      color: white;
    }
    .product-btn.clear {
      border-color: #95a5a6;
      color: #95a5a6;
    }
    .product-btn.clear:hover {
      background: #95a5a6;
      color: white;
    }
    .edit-controls {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid #e0e0e0;
    }
    .edit-toggle {
      padding: 8px 16px;
      border: 2px solid #e74c3c;
      background: white;
      color: #e74c3c;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.9em;
      margin-right: 10px;
    }
    .edit-toggle:hover {
      background: #e74c3c;
      color: white;
    }
    .edit-toggle.active {
      background: #e74c3c;
      color: white;
    }
    .edit-mode-info {
      font-size: 0.8em;
      color: #7f8c8d;
      margin-top: 5px;
    }
    .edit-mode td:not(:first-child) {
      cursor: pointer;
    }
    .edit-mode td:not(:first-child):hover {
      background-color: #f8f9fa !important;
      border-color: #6c757d !important;
    }
    td.selected-for-edit {
      background-color: #fff3cd !important;
      border: 2px solid #ffc107 !important;
      box-shadow: 0 0 5px rgba(255, 193, 7, 0.5);
    }
    .scenario-controls {
      margin-bottom: 20px;
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .scenario-controls h3 {
      margin: 0 0 10px 0;
      color: #2c3e50;
    }
    .scenario-buttons {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }
    .scenario-btn {
      padding: 8px 16px;
      border: 2px solid #9b59b6;
      background: white;
      color: #9b59b6;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.9em;
    }
    .scenario-btn:hover {
      background: #9b59b6;
      color: white;
    }
    .scenario-btn.active {
      background: #9b59b6;
      color: white;
    }
    .scenario-edit-toggle {
      padding: 8px 16px;
      border: 2px solid #8e44ad;
      background: white;
      color: #8e44ad;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.9em;
      margin-right: 10px;
    }
    .scenario-edit-toggle:hover {
      background: #8e44ad;
      color: white;
    }
    .scenario-edit-toggle.active {
      background: #8e44ad;
      color: white;
    }
    .scenario-dot {
      position: absolute;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #9b59b6;
      border: 3px solid white;
      box-shadow: 0 2px 6px rgba(155, 89, 182, 0.5);
      z-index: 100;
      pointer-events: none;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 10px;
      font-weight: bold;
    }
    .scenario-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 50;
    }
    table {
      position: relative;
    }
    td.scenario-selected {
      background-color: #f3e5f5 !important;
      border: 2px solid #9b59b6 !important;
    }
    .factors-panel {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .factors-panel h3 {
      margin: 0 0 10px 0;
      color: #2c3e50;
      font-size: 0.9em;
    }
    .factors-content {
      flex: 1;
    }
    .factors-equalizer-wrapper {
      flex-shrink: 0;
      border-left: 1px solid #e0e0e0;
      padding-left: 20px;
    }
    .factors-equalizer {
      display: flex;
      gap: 12px;
      align-items: flex-end;
      justify-content: space-around;
      padding: 10px;
      background: #ffffff;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
    }
    .factor-slider {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
    }
    .factor-slider label {
      font-size: 0.65em;
      color: #2c3e50;
      text-align: center;
      font-weight: 500;
      min-height: 24px;
      display: flex;
      align-items: center;
      max-width: 60px;
      line-height: 1.1;
    }
    .bar-container {
      position: relative;
      height: 100px;
      width: 30px;
      background: #e8e8e8;
      border-radius: 4px;
      overflow: hidden;
      display: flex;
      flex-direction: column-reverse;
    }
    .bar-fill {
      width: 100%;
      background: linear-gradient(to top, #3498db 0%, #2ecc71 50%, #27ae60 100%);
      transition: height 0.5s ease-out;
      border-radius: 2px;
    }
    .factor-value {
      font-size: 0.7em;
      color: #7f8c8d;
      font-weight: bold;
      min-width: 20px;
      text-align: center;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      background-color: #fff;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
      border-radius: 8px;
      overflow: hidden;
    }
    th {
      background-color: #2c3e50;
      color: #ecf0f1;
      padding: 15px;
      font-size: 1rem;
      text-transform: uppercase;
    }
    td {
      border: 1px solid #e0e0e0;
      padding: 15px;
      text-align: left;
      vertical-align: top;
      position: relative;
      transition: all 0.3s ease;
      font-size: 0.95rem;
      background-color: #ffffff;
    }
    td.highlighted {
      background-color: #e8f4fd !important;
      border: 2px solid #3498db !important;
      box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);
    }
    td.expanded {
      background-color: #f0f8ff;
    }
    td.highlighted.expanded {
      background-color: #d4edfd !important;
    }
    .cell-content {
      display: block;
      font-weight: 500;
      color: #34495e;
    }
    .cell-detail {
      display: none;
      margin-top: 10px;
      font-size: 0.9em;
      color: #7f8c8d;
    }
    .flyout {
      display: none;
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      width: 320px;
      background: #ffffff;
      border: 1px solid #bdc3c7;
      padding: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 1000;
      border-radius: 6px;
      font-size: 0.9em;
      color: #2c3e50;
      margin-top: 5px;
    }
  </style>
</head>
<body>
  <div class="scenario-controls">
    <h3>User Scenarios & Workflows</h3>
    <div style="display: flex; gap: 20px; align-items: flex-start;">
      <div style="flex: 1;">
        <div class="scenario-buttons">
          <button class="scenario-btn" data-scenario="prototype-dev">Developer: Prototype</button>
          <button class="scenario-btn" data-scenario="production-dev">Developer: Production</button>
          <button class="scenario-btn" data-scenario="learning-dev">Developer: Learning</button>
          <button class="scenario-btn" data-scenario="custom-1">Custom Scenario 1</button>
          <button class="scenario-btn clear" data-scenario="clear">Clear Scenario</button>
        </div>
        <div style="margin-top: 10px;">
          <button class="scenario-edit-toggle" id="scenarioEditToggle">Edit Scenario</button>
          <select id="editScenarioSelect" style="display:none; padding: 5px; margin-right: 10px;">
            <option value="prototype-dev">Developer: Prototype</option>
            <option value="production-dev">Developer: Production</option>
            <option value="learning-dev">Developer: Learning</option>
            <option value="custom-1">Custom Scenario 1</option>
          </select>
          <button id="saveScenarioBtn" style="display:none; padding: 5px 12px; background: #27ae60; color: white; border: none; border-radius: 3px; cursor: pointer;">Save</button>
          <button id="cancelScenarioBtn" style="display:none; padding: 5px 12px; background: #95a5a6; color: white; border: none; border-radius: 3px; cursor: pointer; margin-left: 5px;">Cancel</button>
          <button id="resetScenariosBtn" style="padding: 5px 12px; background: #e67e22; color: white; border: none; border-radius: 3px; cursor: pointer; margin-left: 10px;">Reset Scenarios</button>
          <div class="edit-mode-info" id="scenarioEditInfo" style="display:none; margin-top: 5px;">Click on cells in order to create the workflow path. The order matters - cells will be connected in the sequence you click them.</div>
        </div>
      </div>
      <div style="flex-shrink: 0;">
        <h3 style="margin: 0 0 10px 0; color: #2c3e50; font-size: 0.9em;">Situational Factors</h3>
        <div class="factors-equalizer">
      <div class="factor-slider">
        <div class="bar-container">
          <div class="bar-fill" id="bar-importance" style="height: 0%;"></div>
        </div>
        <div class="factor-value" id="value-importance">-</div>
        <label for="bar-importance">Task Importance</label>
      </div>
      <div class="factor-slider">
        <div class="bar-container">
          <div class="bar-fill" id="bar-complexity" style="height: 0%;"></div>
        </div>
        <div class="factor-value" id="value-complexity">-</div>
        <label for="bar-complexity">Task Complexity</label>
      </div>
      <div class="factor-slider">
        <div class="bar-container">
          <div class="bar-fill" id="bar-expertise" style="height: 0%;"></div>
        </div>
        <div class="factor-value" id="value-expertise">-</div>
        <label for="bar-expertise">Human Expertise</label>
      </div>
      <div class="factor-slider">
        <div class="bar-container">
          <div class="bar-fill" id="bar-aicapability" style="height: 0%;"></div>
        </div>
        <div class="factor-value" id="value-aicapability">-</div>
        <label for="bar-aicapability">AI Capability</label>
      </div>
      <div class="factor-slider">
        <div class="bar-container">
          <div class="bar-fill" id="bar-maturity" style="height: 0%;"></div>
        </div>
        <div class="factor-value" id="value-maturity">-</div>
        <label for="bar-maturity">Codebase Maturity</label>
      </div>
      <div class="factor-slider">
        <div class="bar-container">
          <div class="bar-fill" id="bar-governance" style="height: 0%;"></div>
        </div>
        <div class="factor-value" id="value-governance">-</div>
        <label for="bar-governance">Governance & Safety</label>
      </div>
    </div>
      </div>
    </div>
  </div>
  
  <div class="product-selector">
    <h3>Visualize Product Capabilities</h3>
    <div class="product-buttons">
      <button class="product-btn" data-product="github-copilot">GitHub Copilot Completions, NES</button>
      <button class="product-btn" data-product="spec-kit">spec-kit</button>
      <button class="product-btn" data-product="cursor">Cursor IDE</button>
      <button class="product-btn" data-product="claude">Claude</button>
      <button class="product-btn" data-product="copilot-agents">GitHub Copilot Agent Mode</button>
      <button class="product-btn clear" data-product="clear">Clear All</button>
    </div>
    <div class="edit-controls">
      <button class="edit-toggle" id="editModeToggle">Enter Edit Mode</button>
      <select id="editProductSelect" style="display:none; padding: 5px; margin-right: 10px;">
        <option value="github-copilot">GitHub Copilot Completions, NES</option>
        <option value="spec-kit">spec-kit</option>
        <option value="cursor">Cursor IDE</option>
        <option value="claude">Claude</option>
        <option value="copilot-agents">GitHub Copilot Agent Mode</option>
      </select>
      <button id="saveEditBtn" style="display:none; padding: 5px 12px; background: #27ae60; color: white; border: none; border-radius: 3px; cursor: pointer;">Save</button>
      <button id="cancelEditBtn" style="display:none; padding: 5px 12px; background: #95a5a6; color: white; border: none; border-radius: 3px; cursor: pointer; margin-left: 5px;">Cancel</button>
      <button id="resetBtn" style="padding: 5px 12px; background: #e67e22; color: white; border: none; border-radius: 3px; cursor: pointer; margin-left: 10px;">Reset to Defaults</button>
      <div class="edit-mode-info" id="editModeInfo" style="display:none;">Click on cells to select/deselect them for the chosen product. Selected cells will be highlighted in yellow.</div>
    </div>
  </div>
  
  <div style="position: relative;">
    <canvas id="scenarioCanvas" class="scenario-canvas"></canvas>
    <table id="uxTable">
      <thead>
        <tr>
          <th></th>
          <th>Code Focused</th>
          <th>Intent Focused</th>
          <th>Orchestration Focused</th>
        </tr>
      </thead>
      <tbody>
        <tr><th>Tool</th><td></td><td></td><td></td></tr>
        <tr><th>Advisor</th><td></td><td></td><td></td></tr>
        <tr><th>Co-Creator</th><td></td><td></td><td></td></tr>
        <tr><th>Team-Mate</th><td></td><td></td><td></td></tr>
        <tr><th>Delegate</th><td></td><td></td><td></td></tr>
      </tbody>
    </table>
  </div>

  <script>
const data = {
  // ... (keeping the existing data structure)
  "Tool": {
    "Code Focused": {
      "signature": "Local, reactive, low autonomy; optimised for incremental assist.",
      "sentences": [
        "<strong>Set Context:</strong> Context inferred from current artefact; minimal explicit setup.",
        "<strong>Generate/Act:</strong> AI responds to micro-signals; outputs small increments.",
        "<strong>Evaluate:</strong> Quick inline review; accept or ignore instantly.",
        "<strong>Repair/Refine:</strong> Adjust by editing or adding hints; iteration is manual.",
        "<strong>Apply/Ship:</strong> Integrated through normal workflow; no orchestration layer."
      ],
      "detail": "Context is inferred from the current artefact and recent actions. AI reacts to immediate signals with small, context-aware outputs. Human reviews and integrates outputs quickly, making manual refinements as needed. This mode prioritises speed and flow, with minimal trust barriers and no additional orchestration."
    },
    "Intent Focused": {
      "signature": "Reactive to stated goals; bridges natural language and structured outputs.",
      "sentences": [
        "<strong>Set Context:</strong> Context comes from explicit goals or task descriptions.",
        "<strong>Generate/Act:</strong> AI generates outputs aligned to stated intent.",
        "<strong>Evaluate:</strong> Human checks alignment with objectives and constraints.",
        "<strong>Repair/Refine:</strong> Refinement happens by rephrasing or clarifying intent.",
        "<strong>Apply/Ship:</strong> Outputs integrated into workflow after validation."
      ],
      "detail": "Human provides explicit goals or instructions in natural language or structured prompts. AI interprets these and generates outputs aligned with intent. Evaluation focuses on whether outputs meet objectives. Refinement occurs through rephrasing or clarifying goals. Integration follows standard processes."
    },
    "Orchestration Focused": {
      "signature": "Reactive coordination; supports multi-step workflows without autonomy.",
      "sentences": [
        "<strong>Set Context:</strong> Context defined by workflow steps or orchestration scripts.",
        "<strong>Generate/Act:</strong> AI executes discrete tasks within a larger process.",
        "<strong>Evaluate:</strong> Human validates each step before proceeding.",
        "<strong>Repair/Refine:</strong> Refinement involves adjusting workflow parameters.",
        "<strong>Apply/Ship:</strong> Outputs combined into the orchestrated system manually."
      ],
      "detail": "Human defines workflow steps or orchestration scripts. AI executes individual tasks but does not self-direct. Human validates outputs at each stage and adjusts parameters as needed. Integration happens within the orchestrated system, requiring human oversight for sequencing and dependencies."
    }
  },
  "Advisor": {
    "Code Focused": {
      "signature": "Choice-oriented, human-in-control; ideal for trust-building and compliance-heavy work.",
      "sentences": [
        "<strong>Set Context:</strong> Provide richer hints or annotations to frame options.",
        "<strong>Generate/Act:</strong> AI proposes multiple alternatives for comparison.",
        "<strong>Evaluate:</strong> Human weighs trade-offs; higher cognitive load than Tool mode.",
        "<strong>Repair/Refine:</strong> Request new options or tweak framing for better fit.",
        "<strong>Apply/Ship:</strong> Manual integration; standard validation applies."
      ],
      "detail": "Human frames the problem with richer hints or annotations. AI generates multiple alternatives, leaving selection to the human. Evaluation involves comparing trade-offs like efficiency or clarity. Refinement occurs through iterative requests for new options. Integration remains manual, with standard validation."
    },
    "Intent Focused": {
      "signature": "Goal-driven suggestions; supports decision-making without full automation.",
      "sentences": [
        "<strong>Set Context:</strong> Context comes from high-level goals or desired outcomes.",
        "<strong>Generate/Act:</strong> AI offers alternative strategies or plans.",
        "<strong>Evaluate:</strong> Human evaluates feasibility and alignment with objectives.",
        "<strong>Repair/Refine:</strong> Refinement involves clarifying priorities or constraints.",
        "<strong>Apply/Ship:</strong> Chosen approach integrated into workflow manually."
      ],
      "detail": "Human specifies goals or desired outcomes. AI suggests alternative strategies or plans, leaving decision-making to the human. Evaluation focuses on feasibility and alignment. Refinement occurs by clarifying priorities or constraints. Integration is manual, ensuring human control."
    },
    "Orchestration Focused": {
      "signature": "Advisory role in complex workflows; human retains orchestration control.",
      "sentences": [
        "<strong>Set Context:</strong> Context defined by multi-agent or multi-step objectives.",
        "<strong>Generate/Act:</strong> AI suggests orchestration patterns or task allocations.",
        "<strong>Evaluate:</strong> Human validates and selects orchestration strategy.",
        "<strong>Repair/Refine:</strong> Refinement involves adjusting dependencies or sequencing.",
        "<strong>Apply/Ship:</strong> Integration requires manual coordination across systems."
      ],
      "detail": "Human defines multi-step objectives. AI advises on orchestration strategies, such as task allocation or sequencing. Human validates and selects the approach. Refinement involves adjusting dependencies or constraints. Integration requires manual coordination across systems."
    }
  },
  "Co-Creator": {
    "Code Focused": {
      "signature": "Collaborative, high-context, medium autonomy; accelerates creative work.",
      "sentences": [
        "<strong>Set Context:</strong> Supply partial structure or examples to guide AI.",
        "<strong>Generate/Act:</strong> AI contributes substantial components within human direction.",
        "<strong>Evaluate:</strong> Review for correctness and alignment with goals.",
        "<strong>Repair/Refine:</strong> Iterative back-and-forth; conversational adjustments.",
        "<strong>Apply/Ship:</strong> Merge after validation; fits into existing delivery pipeline."
      ],
      "detail": "Human provides partial structure or examples. AI generates substantial components, guided by human direction. Evaluation ensures correctness and alignment. Refinement occurs through iterative, conversational adjustments. Outputs are integrated after validation."
    },
    "Intent Focused": {
      "signature": "Shared authorship; human sets intent, AI fills in details.",
      "sentences": [
        "<strong>Set Context:</strong> Context comes from detailed goals or scenarios.",
        "<strong>Generate/Act:</strong> AI drafts plans or artefacts aligned with intent.",
        "<strong>Evaluate:</strong> Human reviews for completeness and relevance.",
        "<strong>Repair/Refine:</strong> Refinement through iterative clarification of goals.",
        "<strong>Apply/Ship:</strong> Outputs integrated into broader workflow after review."
      ],
      "detail": "Human provides detailed goals or scenarios. AI drafts plans or artefacts aligned with intent. Human reviews for completeness and relevance. Refinement occurs through iterative clarification. Integration follows standard workflows."
    },
    "Orchestration Focused": {
      "signature": "Collaborative orchestration; AI manages sub-tasks under human guidance.",
      "sentences": [
        "<strong>Set Context:</strong> Context defined by overarching objectives and constraints.",
        "<strong>Generate/Act:</strong> AI proposes orchestration plans and executes sub-tasks.",
        "<strong>Evaluate:</strong> Human monitors progress and validates milestones.",
        "<strong>Repair/Refine:</strong> Refinement involves adjusting orchestration logic.",
        "<strong>Apply/Ship:</strong> Outputs integrated into the system after milestone checks."
      ],
      "detail": "Human defines overarching objectives and constraints. AI proposes orchestration plans and executes sub-tasks. Human monitors progress and validates milestones. Refinement involves adjusting orchestration logic. Outputs are integrated after milestone checks."
    }
  },
  "Team-Mate": {
    "Code Focused": {
      "signature": "Goal-driven, semi-autonomous; mirrors human team dynamics.",
      "sentences": [
        "<strong>Set Context:</strong> Define objectives and constraints at a higher level.",
        "<strong>Generate/Act:</strong> AI drafts across multiple artefacts; human monitors.",
        "<strong>Evaluate:</strong> Oversight similar to reviewing a colleague’s work.",
        "<strong>Repair/Refine:</strong> Feedback via structured comments or edits; AI iterates.",
        "<strong>Apply/Ship:</strong> Integration after thorough review and testing."
      ],
      "detail": "Human defines objectives and constraints. AI drafts across multiple artefacts, with human oversight. Evaluation mirrors reviewing a colleague’s work. Refinement occurs through structured feedback. Integration follows thorough review and testing."
    },
    "Intent Focused": {
      "signature": "Semi-autonomous execution; human provides goals, AI plans and acts.",
      "sentences": [
        "<strong>Set Context:</strong> Context comes from high-level goals and constraints.",
        "<strong>Generate/Act:</strong> AI plans steps and executes tasks toward the goal.",
        "<strong>Evaluate:</strong> Human validates progress at checkpoints.",
        "<strong>Repair/Refine:</strong> Refinement involves adjusting goals or priorities.",
        "<strong>Apply/Ship:</strong> Outputs integrated after milestone approval."
      ],
      "detail": "Human provides high-level goals and constraints. AI plans and executes tasks toward the goal. Human validates progress at checkpoints. Refinement occurs by adjusting goals or priorities. Outputs are integrated after milestone approval."
    },
    "Orchestration Focused": {
      "signature": "AI acts as a managed collaborator; executes orchestration plans under oversight.",
      "sentences": [
        "<strong>Set Context:</strong> Context defined by multi-step objectives and dependencies.",
        "<strong>Generate/Act:</strong> AI coordinates agents and resources to achieve goals.",
        "<strong>Evaluate:</strong> Human reviews orchestration outcomes at key stages.",
        "<strong>Repair/Refine:</strong> Refinement involves rebalancing tasks or dependencies.",
        "<strong>Apply/Ship:</strong> Outputs integrated after orchestration validation."
      ],
      "detail": "Human defines multi-step objectives and dependencies. AI coordinates agents and resources to achieve goals. Human reviews orchestration outcomes at key stages. Refinement involves rebalancing tasks or dependencies. Outputs are integrated after validation."
    }
  },
  "Delegate": {
    "Code Focused": {
      "signature": "High autonomy, milestone-driven; ideal for scale and speed under governance.",
      "sentences": [
        "<strong>Set Context:</strong> Specify goals and constraints in structured form.",
        "<strong>Generate/Act:</strong> AI executes large portions independently.",
        "<strong>Evaluate:</strong> Validate outputs at checkpoints, not line-by-line.",
        "<strong>Repair/Refine:</strong> Adjust goals or constraints rather than micro details.",
        "<strong>Apply/Ship:</strong> Integrate after milestone validation and dependency checks."
      ],
      "detail": "Human specifies goals and constraints in structured form. AI executes large portions independently. Human validates outputs at milestones. Refinement occurs at the goal level. Integration follows milestone validation and dependency checks."
    },
    "Intent Focused": {
      "signature": "AI owns execution; human defines intent and validates outcomes.",
      "sentences": [
        "<strong>Set Context:</strong> Context comes from explicit goals and success criteria.",
        "<strong>Generate/Act:</strong> AI autonomously plans and executes tasks.",
        "<strong>Evaluate:</strong> Human validates outputs against objectives.",
        "<strong>Repair/Refine:</strong> Refinement involves redefining goals or constraints.",
        "<strong>Apply/Ship:</strong> Outputs integrated after final approval."
      ],
      "detail": "Human defines explicit goals and success criteria. AI autonomously plans and executes tasks. Human validates outputs against objectives. Refinement occurs by redefining goals or constraints. Outputs are integrated after final approval."
    },
    "Orchestration Focused": {
      "signature": "Full orchestration autonomy; human sets direction and validates milestones.",
      "sentences": [
        "<strong>Set Context:</strong> Context defined by overarching objectives and governance rules.",
        "<strong>Generate/Act:</strong> AI manages orchestration end-to-end across agents and systems.",
        "<strong>Evaluate:</strong> Human validates at major milestones only.",
        "<strong>Repair/Refine:</strong> Refinement involves adjusting governance or objectives.",
        "<strong>Apply/Ship:</strong> Outputs integrated automatically after approval."
      ],
      "detail": "Human defines overarching objectives and governance rules. AI manages orchestration end-to-end across agents and systems. Human validates at major milestones. Refinement occurs by adjusting governance or objectives. Outputs are integrated automatically after approval."
    }
  }
};
    const table = document.getElementById('uxTable');
    const scenarioCanvas = document.getElementById('scenarioCanvas');
    const scenarioCtx = scenarioCanvas.getContext('2d');
    let currentScenario = null;
    let activeCell = null;
    let flyoutTimer = null;

    for (let row of table.rows) {
      for (let cell of row.cells) {
        if (cell.cellIndex === 0 || row.rowIndex === 0) continue;
        const rowLabel = table.rows[cell.parentNode.rowIndex].cells[0].textContent;
        const colLabel = table.rows[0].cells[cell.cellIndex].textContent;
        const cellData = data[rowLabel]?.[colLabel];
        if (!cellData) continue;

        cell.innerHTML = `<span class="cell-content">${cellData.signature}</span><div class="cell-detail" style="display: block;">${cellData.sentences.join('<br>')}</div><div class="flyout">${cellData.detail}</div>`;

        cell.addEventListener('mouseenter', () => {
          if (activeCell && activeCell !== cell) {
            activeCell.classList.remove('expanded');
            activeCell.querySelector('.flyout').style.display = 'none';
            clearTimeout(flyoutTimer);
          }
          cell.classList.add('expanded');
          flyoutTimer = setTimeout(() => {
            const flyout = cell.querySelector('.flyout');
            const isLastRow = cell.parentNode.rowIndex === table.rows.length - 1;
            if (isLastRow) {
              flyout.style.top = 'auto';
              flyout.style.bottom = '100%';
              flyout.style.marginTop = '0';
              flyout.style.marginBottom = '5px';
            } else {
              flyout.style.top = '100%';
              flyout.style.bottom = 'auto';
              flyout.style.marginTop = '5px';
              flyout.style.marginBottom = '0';
            }
            flyout.style.display = 'block';
          }, 1000);
          activeCell = cell;
        });

        cell.addEventListener('mouseleave', () => {
          clearTimeout(flyoutTimer);
          cell.classList.remove('expanded');
          cell.querySelector('.flyout').style.display = 'none';
        });
      }
    }

    // Initialize canvas size
    function resizeCanvas() {
      const tableRect = table.getBoundingClientRect();
      scenarioCanvas.width = tableRect.width;
      scenarioCanvas.height = tableRect.height;
      if (currentScenario) {
        drawScenario(currentScenario);
      }
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Scenario visualization functions
    function drawScenario(scenarioKey) {
      currentScenario = scenarioKey;
      clearScenarioVisualization();
      
      const workflow = scenarios[scenarioKey] || [];
      if (workflow.length === 0) return;

      resizeCanvas();
      
      // Clear existing dots
      document.querySelectorAll('.scenario-dot').forEach(dot => dot.remove());
      document.querySelectorAll('td.scenario-selected').forEach(cell => cell.classList.remove('scenario-selected'));

      const points = [];
      
      // Create dots and collect points
      workflow.forEach(([role, focus], index) => {
        const cell = findCell(role, focus);
        if (cell) {
          cell.classList.add('scenario-selected');
          
          // Create dot
          const dot = document.createElement('div');
          dot.className = 'scenario-dot';
          dot.textContent = index + 1;
          
          const cellRect = cell.getBoundingClientRect();
          const tableRect = table.getBoundingClientRect();
          
          const x = cellRect.left - tableRect.left + cellRect.width / 2;
          const y = cellRect.top - tableRect.top + cellRect.height / 2;
          
          dot.style.left = (x - 10) + 'px';
          dot.style.top = (y - 10) + 'px';
          
          table.parentElement.appendChild(dot);
          
          points.push({ x, y });
        }
      });

      // Draw lines connecting the dots
      if (points.length > 1) {
        scenarioCtx.clearRect(0, 0, scenarioCanvas.width, scenarioCanvas.height);
        scenarioCtx.strokeStyle = '#9b59b6';
        scenarioCtx.lineWidth = 3;
        scenarioCtx.setLineDash([5, 5]);
        scenarioCtx.lineCap = 'round';
        scenarioCtx.lineJoin = 'round';

        // Draw curved lines between points
        for (let i = 0; i < points.length - 1; i++) {
          const p1 = points[i];
          const p2 = points[i + 1];
          
          // Calculate control points for quadratic curve
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          // Create a curve that bends perpendicular to the line
          // The amount of curve is proportional to the distance
          const curvature = Math.min(distance * 0.3, 50);
          
          // Calculate perpendicular direction
          const perpX = -dy / distance;
          const perpY = dx / distance;
          
          // Control point is offset perpendicular to the line
          const controlX = (p1.x + p2.x) / 2 + perpX * curvature;
          const controlY = (p1.y + p2.y) / 2 + perpY * curvature;
          
          scenarioCtx.beginPath();
          scenarioCtx.moveTo(p1.x, p1.y);
          scenarioCtx.quadraticCurveTo(controlX, controlY, p2.x, p2.y);
          scenarioCtx.stroke();
        }
      }
    }

    function clearScenarioVisualization() {
      scenarioCtx.clearRect(0, 0, scenarioCanvas.width, scenarioCanvas.height);
      document.querySelectorAll('.scenario-dot').forEach(dot => dot.remove());
      document.querySelectorAll('td.scenario-selected').forEach(cell => cell.classList.remove('scenario-selected'));
      currentScenario = null;
    }

    // Product capability mapping
    const defaultProductCapabilities = {
      'github-copilot': [
        ['Tool', 'Code Focused'],
        ['Advisor', 'Code Focused'],
        ['Co-Creator', 'Code Focused']
      ],
      'spec-kit': [
        ['Advisor', 'Intent Focused'],
        ['Co-Creator', 'Intent Focused'],
        ['Team-Mate', 'Intent Focused']
      ],
      'cursor': [
        ['Tool', 'Code Focused'],
        ['Co-Creator', 'Code Focused'],
        ['Team-Mate', 'Code Focused']
      ],
      'claude': [
        ['Advisor', 'Intent Focused'],
        ['Co-Creator', 'Intent Focused'],
        ['Team-Mate', 'Intent Focused'],
        ['Delegate', 'Intent Focused']
      ],
      'copilot-agents': [
        ['Co-Creator', 'Intent Focused'],
        ['Team-Mate', 'Intent Focused']
      ]
    };

    // Load product capabilities from localStorage or use defaults
    let productCapabilities = loadProductCapabilities();

    // Default scenario workflows
    const defaultScenarios = {
      'prototype-dev': [
        ['Tool', 'Code Focused'],
        ['Co-Creator', 'Code Focused'],
        ['Advisor', 'Code Focused'],
        ['Tool', 'Code Focused']
      ],
      'production-dev': [
        ['Co-Creator', 'Code Focused'],
        ['Team-Mate', 'Code Focused'],
        ['Advisor', 'Code Focused'],
        ['Team-Mate', 'Code Focused']
      ],
      'learning-dev': [
        ['Advisor', 'Intent Focused'],
        ['Co-Creator', 'Intent Focused'],
        ['Tool', 'Code Focused'],
        ['Advisor', 'Code Focused']
      ],
      'custom-1': []
    };

    // Situational factors for each scenario (0-100 scale)
    // Higher values = more of that factor
    const scenarioFactors = {
      'prototype-dev': {
        importance: 30,      // Low importance - experimental
        complexity: 40,      // Lower complexity - proving concept
        expertise: 60,       // Moderate expertise - exploring
        aicapability: 70,    // High AI capability - leveraging tools
        maturity: 20,        // Low maturity - new codebase
        governance: 20       // Low governance - move fast
      },
      'production-dev': {
        importance: 85,      // High importance - production code
        complexity: 70,      // Higher complexity - real features
        expertise: 75,       // Higher expertise - professional work
        aicapability: 65,    // Good AI capability - reliable assistant
        maturity: 80,        // High maturity - established codebase
        governance: 80       // High governance - safety critical
      },
      'learning-dev': {
        importance: 40,      // Moderate importance - learning exercise
        complexity: 50,      // Moderate complexity - learning curve
        expertise: 25,       // Low expertise - still learning
        aicapability: 60,    // Moderate AI capability - teaching aid
        maturity: 30,        // Low maturity - practice projects
        governance: 30       // Low governance - exploration
      },
      'custom-1': {
        importance: 50,
        complexity: 50,
        expertise: 50,
        aicapability: 50,
        maturity: 50,
        governance: 50
      }
    };

    // Load scenarios from localStorage or use defaults
    let scenarios = loadScenarios();

    function saveScenarios() {
      try {
        localStorage.setItem('uxTableScenarios', JSON.stringify(scenarios));
      } catch (error) {
        console.warn('Failed to save scenarios to localStorage:', error);
      }
    }

    function loadScenarios() {
      try {
        const saved = localStorage.getItem('uxTableScenarios');
        if (saved) {
          return JSON.parse(saved);
        }
      } catch (error) {
        console.warn('Failed to load scenarios from localStorage:', error);
      }
      return JSON.parse(JSON.stringify(defaultScenarios));
    }

    function resetScenarios() {
      scenarios = JSON.parse(JSON.stringify(defaultScenarios));
      saveScenarios();
      clearScenarioVisualization();
    }

    function saveProductCapabilities() {
      try {
        localStorage.setItem('uxTableProductCapabilities', JSON.stringify(productCapabilities));
      } catch (error) {
        console.warn('Failed to save product capabilities to localStorage:', error);
      }
    }

    function loadProductCapabilities() {
      try {
        const saved = localStorage.getItem('uxTableProductCapabilities');
        if (saved) {
          return JSON.parse(saved);
        }
      } catch (error) {
        console.warn('Failed to load product capabilities from localStorage:', error);
      }
      // Return a copy of defaults if nothing saved or error occurred
      return JSON.parse(JSON.stringify(defaultProductCapabilities));
    }

    function resetToDefaults() {
      productCapabilities = JSON.parse(JSON.stringify(defaultProductCapabilities));
      saveProductCapabilities();
      // Clear any current highlights
      document.querySelectorAll('.product-btn').forEach(b => b.classList.remove('active'));
      document.querySelectorAll('td.highlighted').forEach(cell => cell.classList.remove('highlighted'));
    }

    // Product button event handlers
    document.querySelectorAll('.product-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const product = btn.dataset.product;
        
        // Clear all highlights and active states
        document.querySelectorAll('.product-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('td.highlighted').forEach(cell => cell.classList.remove('highlighted'));
        
        if (product === 'clear') return;
        
        // Set active button
        btn.classList.add('active');
        
        // Highlight relevant cells
        const capabilities = productCapabilities[product] || [];
        capabilities.forEach(([role, focus]) => {
          const cell = findCell(role, focus);
          if (cell) {
            cell.classList.add('highlighted');
          }
        });
      });
    });

    function findCell(role, focus) {
      for (let row of table.rows) {
        if (row.cells[0].textContent === role) {
          for (let cell of row.cells) {
            const colLabel = table.rows[0].cells[cell.cellIndex].textContent;
            if (colLabel === focus) {
              return cell;
            }
          }
        }
      }
      return null;
    }

    // Function to update factor sliders
    function updateFactorSliders(scenarioKey) {
      const factors = scenarioFactors[scenarioKey];
      if (!factors) return;

      const factorNames = ['importance', 'complexity', 'expertise', 'aicapability', 'maturity', 'governance'];
      
      factorNames.forEach(name => {
        const bar = document.getElementById(`bar-${name}`);
        const valueDisplay = document.getElementById(`value-${name}`);
        const value = factors[name];
        
        if (bar && valueDisplay) {
          // Get current height percentage
          const currentHeight = parseFloat(bar.style.height) || 0;
          const targetHeight = value;
          const duration = 500; // milliseconds
          const startTime = performance.now();
          
          function animate(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // Ease-out animation
            const easeProgress = 1 - Math.pow(1 - progress, 3);
            const currentValue = Math.round(currentHeight + (targetHeight - currentHeight) * easeProgress);
            
            bar.style.height = currentValue + '%';
            valueDisplay.textContent = currentValue;
            
            if (progress < 1) {
              requestAnimationFrame(animate);
            }
          }
          
          requestAnimationFrame(animate);
        }
      });
    }

    // Function to clear factor sliders
    function clearFactorSliders() {
      const factorNames = ['importance', 'complexity', 'expertise', 'aicapability', 'maturity', 'governance'];
      
      factorNames.forEach(name => {
        const bar = document.getElementById(`bar-${name}`);
        const valueDisplay = document.getElementById(`value-${name}`);
        
        if (bar && valueDisplay) {
          const currentHeight = parseFloat(bar.style.height) || 0;
          const targetHeight = 0;
          const duration = 500;
          const startTime = performance.now();
          
          function animate(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            const easeProgress = 1 - Math.pow(1 - progress, 3);
            const currentValue = Math.round(currentHeight + (targetHeight - currentHeight) * easeProgress);
            
            bar.style.height = currentValue + '%';
            
            if (progress >= 1) {
              valueDisplay.textContent = '-';
            } else {
              valueDisplay.textContent = currentValue;
            }
            
            if (progress < 1) {
              requestAnimationFrame(animate);
            }
          }
          
          requestAnimationFrame(animate);
        }
      });
    }

    // Scenario button event handlers
    document.querySelectorAll('.scenario-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const scenario = btn.dataset.scenario;
        
        // Clear active states
        document.querySelectorAll('.scenario-btn').forEach(b => b.classList.remove('active'));
        
        if (scenario === 'clear') {
          clearScenarioVisualization();
          clearFactorSliders();
          return;
        }
        
        // Set active button
        btn.classList.add('active');
        
        // Update factor sliders
        updateFactorSliders(scenario);
        
        // Draw scenario
        drawScenario(scenario);
      });
    });

    // Scenario edit mode
    let scenarioEditMode = false;
    let tempScenarioSelections = [];
    
    const scenarioEditToggle = document.getElementById('scenarioEditToggle');
    const editScenarioSelect = document.getElementById('editScenarioSelect');
    const saveScenarioBtn = document.getElementById('saveScenarioBtn');
    const cancelScenarioBtn = document.getElementById('cancelScenarioBtn');
    const resetScenariosBtn = document.getElementById('resetScenariosBtn');
    const scenarioEditInfo = document.getElementById('scenarioEditInfo');
    
    scenarioEditToggle.addEventListener('click', () => {
      if (!scenarioEditMode) {
        enterScenarioEditMode();
      } else {
        exitScenarioEditMode();
      }
    });
    
    editScenarioSelect.addEventListener('change', () => {
      if (scenarioEditMode) {
        loadExistingScenarioSelections();
      }
    });
    
    saveScenarioBtn.addEventListener('click', () => {
      const selectedScenario = editScenarioSelect.value;
      if (selectedScenario) {
        scenarios[selectedScenario] = tempScenarioSelections.map(cell => {
          const role = table.rows[cell.parentNode.rowIndex].cells[0].textContent;
          const focus = table.rows[0].cells[cell.cellIndex].textContent;
          return [role, focus];
        });
        saveScenarios();
      }
      exitScenarioEditMode();
    });
    
    cancelScenarioBtn.addEventListener('click', () => {
      exitScenarioEditMode();
    });
    
    resetScenariosBtn.addEventListener('click', () => {
      if (confirm('Are you sure you want to reset all scenarios to their default workflows?')) {
        resetScenarios();
      }
    });
    
    function enterScenarioEditMode() {
      scenarioEditMode = true;
      tempScenarioSelections = [];
      
      // Clear scenario visualization
      clearScenarioVisualization();
      
      // Update UI
      scenarioEditToggle.textContent = 'Exit Scenario Edit';
      scenarioEditToggle.classList.add('active');
      editScenarioSelect.style.display = 'inline';
      saveScenarioBtn.style.display = 'inline';
      cancelScenarioBtn.style.display = 'inline';
      scenarioEditInfo.style.display = 'block';
      
      // Disable product buttons
      document.querySelectorAll('.scenario-btn').forEach(b => b.disabled = true);
      
      // Add click handlers
      addScenarioEditClickHandlers();
      
      // Load existing selections
      loadExistingScenarioSelections();
    }
    
    function exitScenarioEditMode() {
      scenarioEditMode = false;
      
      // Update UI
      scenarioEditToggle.textContent = 'Edit Scenario';
      scenarioEditToggle.classList.remove('active');
      editScenarioSelect.style.display = 'none';
      saveScenarioBtn.style.display = 'none';
      cancelScenarioBtn.style.display = 'none';
      scenarioEditInfo.style.display = 'none';
      
      // Enable product buttons
      document.querySelectorAll('.scenario-btn').forEach(b => b.disabled = false);
      
      // Clear temp selections
      clearScenarioEditSelections();
      tempScenarioSelections = [];
      
      // Remove click handlers
      removeScenarioEditClickHandlers();
    }
    
    function addScenarioEditClickHandlers() {
      for (let row of table.rows) {
        for (let cell of row.cells) {
          if (cell.cellIndex === 0 || row.rowIndex === 0) continue;
          cell.addEventListener('click', handleScenarioEditCellClick);
        }
      }
    }
    
    function removeScenarioEditClickHandlers() {
      for (let row of table.rows) {
        for (let cell of row.cells) {
          if (cell.cellIndex === 0 || row.rowIndex === 0) continue;
          cell.removeEventListener('click', handleScenarioEditCellClick);
        }
      }
    }
    
    function handleScenarioEditCellClick(event) {
      if (!scenarioEditMode) return;
      
      const cell = event.currentTarget;
      const index = tempScenarioSelections.indexOf(cell);
      
      if (index > -1) {
        // Remove this cell and all subsequent cells
        tempScenarioSelections.splice(index);
      } else {
        // Add to sequence
        tempScenarioSelections.push(cell);
      }
      
      // Redraw
      visualizeScenarioEdit();
    }
    
    function loadExistingScenarioSelections() {
      tempScenarioSelections = [];
      clearScenarioEditSelections();
      
      const selectedScenario = editScenarioSelect.value;
      const workflow = scenarios[selectedScenario] || [];
      
      workflow.forEach(([role, focus]) => {
        const cell = findCell(role, focus);
        if (cell) {
          tempScenarioSelections.push(cell);
        }
      });
      
      visualizeScenarioEdit();
    }
    
    function visualizeScenarioEdit() {
      clearScenarioEditSelections();
      
      if (tempScenarioSelections.length === 0) return;

      const points = [];
      
      tempScenarioSelections.forEach((cell, index) => {
        cell.classList.add('scenario-selected');
        
        // Create numbered dot
        const dot = document.createElement('div');
        dot.className = 'scenario-dot';
        dot.textContent = index + 1;
        
        const cellRect = cell.getBoundingClientRect();
        const tableRect = table.getBoundingClientRect();
        
        const x = cellRect.left - tableRect.left + cellRect.width / 2;
        const y = cellRect.top - tableRect.top + cellRect.height / 2;
        
        dot.style.left = (x - 10) + 'px';
        dot.style.top = (y - 10) + 'px';
        
        table.parentElement.appendChild(dot);
        points.push({ x, y });
      });

      // Draw connecting lines
      if (points.length > 1) {
        resizeCanvas();
        scenarioCtx.clearRect(0, 0, scenarioCanvas.width, scenarioCanvas.height);
        scenarioCtx.strokeStyle = '#9b59b6';
        scenarioCtx.lineWidth = 3;
        scenarioCtx.setLineDash([5, 5]);
        scenarioCtx.lineCap = 'round';
        scenarioCtx.lineJoin = 'round';

        // Draw curved lines between points
        for (let i = 0; i < points.length - 1; i++) {
          const p1 = points[i];
          const p2 = points[i + 1];
          
          // Calculate control points for quadratic curve
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          // Create a curve that bends perpendicular to the line
          // The amount of curve is proportional to the distance
          const curvature = Math.min(distance * 0.3, 50);
          
          // Calculate perpendicular direction
          const perpX = -dy / distance;
          const perpY = dx / distance;
          
          // Control point is offset perpendicular to the line
          const controlX = (p1.x + p2.x) / 2 + perpX * curvature;
          const controlY = (p1.y + p2.y) / 2 + perpY * curvature;
          
          scenarioCtx.beginPath();
          scenarioCtx.moveTo(p1.x, p1.y);
          scenarioCtx.quadraticCurveTo(controlX, controlY, p2.x, p2.y);
          scenarioCtx.stroke();
        }
      }
    }
    
    function clearScenarioEditSelections() {
      scenarioCtx.clearRect(0, 0, scenarioCanvas.width, scenarioCanvas.height);
      document.querySelectorAll('.scenario-dot').forEach(dot => dot.remove());
      document.querySelectorAll('td.scenario-selected').forEach(cell => cell.classList.remove('scenario-selected'));
    }

    // Edit mode functionality
    let editMode = false;
    let tempSelections = [];
    
    const editToggle = document.getElementById('editModeToggle');
    const editProductSelect = document.getElementById('editProductSelect');
    const saveEditBtn = document.getElementById('saveEditBtn');
    const cancelEditBtn = document.getElementById('cancelEditBtn');
    const resetBtn = document.getElementById('resetBtn');
    const editModeInfo = document.getElementById('editModeInfo');
    
    editToggle.addEventListener('click', () => {
      if (!editMode) {
        enterEditMode();
      } else {
        exitEditMode();
      }
    });
    
    resetBtn.addEventListener('click', () => {
      if (confirm('Are you sure you want to reset all product mappings to their default values? This will overwrite any custom changes you have made.')) {
        resetToDefaults();
      }
    });
    
    editProductSelect.addEventListener('change', () => {
      if (editMode) {
        loadExistingSelections();
      }
    });
    
    saveEditBtn.addEventListener('click', () => {
      const selectedProduct = editProductSelect.value;
      if (selectedProduct) {
        // Convert temp selections to product capability format
        productCapabilities[selectedProduct] = tempSelections.map(cell => {
          const role = table.rows[cell.parentNode.rowIndex].cells[0].textContent;
          const focus = table.rows[0].cells[cell.cellIndex].textContent;
          return [role, focus];
        });
        // Save to localStorage
        saveProductCapabilities();
      }
      exitEditMode();
    });
    
    cancelEditBtn.addEventListener('click', () => {
      exitEditMode();
    });
    
    function enterEditMode() {
      editMode = true;
      tempSelections = [];
      
      // Update UI
      editToggle.textContent = 'Exit Edit Mode';
      editToggle.classList.add('active');
      editProductSelect.style.display = 'inline';
      saveEditBtn.style.display = 'inline';
      cancelEditBtn.style.display = 'inline';
      editModeInfo.style.display = 'block';
      document.body.classList.add('edit-mode');
      
      // Clear existing highlights
      document.querySelectorAll('.product-btn').forEach(b => b.classList.remove('active'));
      document.querySelectorAll('td.highlighted').forEach(cell => cell.classList.remove('highlighted'));
      
      // Add click handlers to cells
      addEditClickHandlers();
      
      // Load existing selections for the currently selected product
      loadExistingSelections();
    }
    
    function exitEditMode() {
      editMode = false;
      
      // Update UI
      editToggle.textContent = 'Enter Edit Mode';
      editToggle.classList.remove('active');
      editProductSelect.style.display = 'none';
      saveEditBtn.style.display = 'none';
      cancelEditBtn.style.display = 'none';
      editModeInfo.style.display = 'none';
      document.body.classList.remove('edit-mode');
      
      // Clear temp selections
      document.querySelectorAll('td.selected-for-edit').forEach(cell => {
        cell.classList.remove('selected-for-edit');
      });
      tempSelections = [];
      
      // Remove edit click handlers
      removeEditClickHandlers();
    }
    
    function addEditClickHandlers() {
      for (let row of table.rows) {
        for (let cell of row.cells) {
          if (cell.cellIndex === 0 || row.rowIndex === 0) continue;
          cell.addEventListener('click', handleEditCellClick);
        }
      }
    }
    
    function removeEditClickHandlers() {
      for (let row of table.rows) {
        for (let cell of row.cells) {
          if (cell.cellIndex === 0 || row.rowIndex === 0) continue;
          cell.removeEventListener('click', handleEditCellClick);
        }
      }
    }
    
    function handleEditCellClick(event) {
      if (!editMode) return;
      
      const cell = event.currentTarget;
      const index = tempSelections.indexOf(cell);
      
      if (index > -1) {
        // Deselect
        tempSelections.splice(index, 1);
        cell.classList.remove('selected-for-edit');
      } else {
        // Select
        tempSelections.push(cell);
        cell.classList.add('selected-for-edit');
      }
    }
    
    function loadExistingSelections() {
      // Clear current temp selections
      document.querySelectorAll('td.selected-for-edit').forEach(cell => {
        cell.classList.remove('selected-for-edit');
      });
      tempSelections = [];
      
      const selectedProduct = editProductSelect.value;
      const existingCapabilities = productCapabilities[selectedProduct] || [];
      
      // Find and select existing cells
      existingCapabilities.forEach(([role, focus]) => {
        const cell = findCell(role, focus);
        if (cell) {
          cell.classList.add('selected-for-edit');
          tempSelections.push(cell);
        }
      });
    }
  </script>
</body>
</html>
