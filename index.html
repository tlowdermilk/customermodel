
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>AI-Assisted Coding - Interactive Customer Insight Model</title>
  <style>
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f4f6f8;
      margin: 0;
      padding: 20px;
    }
    .product-selector {
      margin-bottom: 20px;
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .product-selector h3 {
      margin: 0 0 10px 0;
      color: #2c3e50;
    }
    .product-buttons {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .product-btn {
      padding: 8px 16px;
      border: 2px solid #3498db;
      background: white;
      color: #3498db;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.9em;
    }
    .product-btn:hover {
      background: #3498db;
      color: white;
    }
    .product-btn.active {
      background: #3498db;
      color: white;
    }
    .edit-controls {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid #e0e0e0;
    }
    .edit-toggle {
      padding: 8px 16px;
      border: 2px solid #3498db;
      background: white;
      color: #3498db;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.9em;
      margin-right: 10px;
    }
    .edit-toggle:hover {
      background: #3498db;
      color: white;
    }
    .edit-toggle.active {
      background: #3498db;
      color: white;
    }
    .edit-mode-info {
      font-size: 0.8em;
      color: #7f8c8d;
      margin-top: 5px;
    }
    .edit-mode td:not(:first-child) {
      cursor: pointer;
    }
    .edit-mode td:not(:first-child):hover {
      background-color: #f8f9fa !important;
      border-color: #6c757d !important;
    }
    td.selected-for-edit {
      background-color: #fff3cd !important;
      border: 2px solid #ffc107 !important;
      box-shadow: 0 0 5px rgba(255, 193, 7, 0.5);
    }
    .preset-controls {
      margin-bottom: 20px;
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .preset-controls h3 {
      margin: 0 0 10px 0;
      color: #2c3e50;
    }
    .preset-buttons {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }
    .preset-btn {
      padding: 8px 16px;
      border: 2px solid #9b59b6;
      background: white;
      color: #9b59b6;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.9em;
    }
    .preset-btn:hover {
      background: #9b59b6;
      color: white;
    }
    .preset-btn.active {
      background: #9b59b6;
      color: white;
    }
    .preset-edit-toggle {
      padding: 8px 16px;
      border: 2px solid #8e44ad;
      background: white;
      color: #8e44ad;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.9em;
      margin-right: 10px;
    }
    .preset-edit-toggle:hover {
      background: #8e44ad;
      color: white;
    }
    .preset-edit-toggle.active {
      background: #8e44ad;
      color: white;
    }
    .preset-dot {
      position: absolute;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #9b59b6;
      border: 3px solid white;
      box-shadow: 0 2px 6px rgba(155, 89, 182, 0.5);
      z-index: 100;
      pointer-events: none;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 10px;
      font-weight: bold;
    }
    .preset-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 50;
    }
    table {
      position: relative;
    }
    td.preset-selected {
      background-color: #f3e5f5 !important;
      border: 2px solid #9b59b6 !important;
    }
    .factors-panel {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .factors-panel h3 {
      margin: 0 0 10px 0;
      color: #2c3e50;
      font-size: 0.9em;
    }
    .factors-content {
      flex: 1;
    }
    .factors-equalizer-wrapper {
      flex-shrink: 0;
      border-left: 1px solid #e0e0e0;
      padding-left: 20px;
    }
    .factors-equalizer {
      display: flex;
      gap: 12px;
      align-items: flex-end;
      justify-content: space-around;
      padding: 10px;
      background: #ffffff;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
    }
    .factor-slider {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
    }
    .factor-slider label {
      font-size: 0.65em;
      color: #2c3e50;
      text-align: center;
      font-weight: 500;
      min-height: 24px;
      display: flex;
      align-items: center;
      max-width: 60px;
      line-height: 1.1;
    }
    .bar-container {
      position: relative;
      height: 100px;
      width: 30px;
      background: #e8e8e8;
      border-radius: 4px;
      overflow: hidden;
      display: flex;
      flex-direction: column-reverse;
    }
    .bar-container:hover {
      background: #d0d0d0;
    }
    .bar-container[data-factor] {
      border: 2px solid #3498db;
      background: #f0f8ff;
    }
    .bar-container[data-factor]:hover {
      border-color: #2980b9;
      background: #e6f3ff;
    }
    .bar-fill {
      width: 100%;
      background: linear-gradient(to top, #774591 0%, #58336b 100%);
      transition: height 0.5s ease-out;
      border-radius: 2px;
    }
    .factor-value {
      font-size: 0.7em;
      color: #7f8c8d;
      font-weight: bold;
      min-width: 20px;
      text-align: center;
    }
    .factor-input {
      width: 48px;
      padding: 4px 6px;
      border: 1px solid #bdc3c7;
      border-radius: 4px;
      font-size: 0.7em;
      text-align: center;
      color: #2c3e50;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
      display: none;
    }
    .factor-input:disabled {
      background-color: #f4f6f8;
      color: #95a5a6;
      cursor: not-allowed;
    }
    .factor-input:not(:disabled):focus {
      outline: none;
      border-color: #9b59b6;
      box-shadow: 0 0 0 2px rgba(155, 89, 182, 0.15);
    }
    .panel-header {
      display: flex;
      justify-content: flex-start;
      align-items: center;
      cursor: pointer;
      margin: 0 0 10px 0;
      color: #2c3e50;
      gap: 10px;
    }
    .panel-title {
      flex-grow: 1;
    }
    .collapse-btn {
      background: none;
      border: 1px solid #bdc3c7;
      border-radius: 3px;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 16px;
      color: #7f8c8d;
      transition: all 0.2s ease;
      flex-shrink: 0;
      order: -1;
    }
    .collapse-btn:hover {
      background: #ecf0f1;
      color: #2c3e50;
    }
    .panel-content {
      transition: all 0.3s ease;
      overflow: hidden;
    }
    .panel-content.collapsed {
      display: none;
    }
    .preset-panel-layout {
      display: flex;
      gap: 20px;
      align-items: flex-start;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      background-color: #fff;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
      border-radius: 8px;
      overflow: hidden;
    }
    th {
      background-color: #2c3e50;
      color: #ecf0f1;
      padding: 15px;
      font-size: 1rem;
      text-transform: uppercase;
    }
    td {
      border: 1px solid #e0e0e0;
      padding: 15px;
      text-align: left;
      vertical-align: top;
      position: relative;
      transition: all 0.3s ease;
      font-size: 0.95rem;
      background-color: #ffffff;
    }
    td.highlighted {
      background-color: #e8f4fd !important;
      border: 2px solid #3498db !important;
      box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);
    }
    td.expanded {
      background-color: #f0f8ff;
    }
    td.highlighted.expanded {
      background-color: #d4edfd !important;
    }
    .cell-content {
      display: block;
      font-weight: 500;
      color: #34495e;
    }
    .cell-detail {
      display: none;
      margin-top: 10px;
      font-size: 0.9em;
      color: #7f8c8d;
    }
    .flyout {
      display: none;
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      width: 320px;
      background: #ffffff;
      border: 1px solid #bdc3c7;
      padding: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 1000;
      border-radius: 6px;
      font-size: 0.9em;
      color: #2c3e50;
      margin-top: 5px;
    }
    
    /* New edit mode UI styles */
    .edit-icon-btn {
      padding: 6px 10px;
      border: 2px solid #8e44ad;
      background: white;
      color: #8e44ad;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 1.2em;
      line-height: 1;
      flex-shrink: 0;
    }
    .edit-icon-btn:hover {
      background: #8e44ad;
      color: white;
    }
    .edit-icon-btn.active {
      background: #8e44ad;
      color: white;
    }
    .add-btn {
      padding: 6px 10px;
      border: 2px solid #16a085;
      background: white;
      color: #16a085;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 1.2em;
      line-height: 1;
      flex-shrink: 0;
    }
    .add-btn:hover {
      background: #16a085;
      color: white;
    }
    .preset-btn.edit-mode-active {
      cursor: pointer;
      box-shadow: 0 0 0 2px #8e44ad;
    }
    .preset-btn.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
  </style>
</head>
<body>
  <!-- Data now persisted to Azure MySQL database automatically on save -->
  
  <div class="preset-controls">
    <h3 class="panel-header" id="presetPanelHeader">
      <span class="panel-title">Profile Presets</span>
      <button class="collapse-btn" id="presetCollapseBtn">−</button>
    </h3>
    <div class="panel-content preset-panel-layout" id="presetPanelContent">
      <div style="flex: 1;">
        <div style="display: flex; align-items: center; gap: 8px;">
          <div class="preset-buttons" id="presetButtonsContainer" style="display: flex; gap: 8px; flex-wrap: wrap; flex: 1;">
            <!-- Preset buttons will be dynamically generated here -->
          </div>
          <button class="edit-icon-btn" id="presetEditToggle" title="Edit Profile Presets">✏️</button>
        </div>
        <div id="presetEmptyMessage" style="display: none; padding: 10px 0; color: #666; font-style: italic;">
          No profiles available. Press "+" to create a profile.
        </div>
        <div id="presetEditControls" style="display:none; margin-top: 10px;">
          <button id="exitPresetEditBtn" style="padding: 5px 12px; background: #95a5a6; color: white; border: none; border-radius: 3px; cursor: pointer; margin-right: 5px;">Exit</button>
          <button id="renamePresetBtn" style="padding: 5px 12px; background: #3498db; color: white; border: none; border-radius: 3px; cursor: pointer; margin-right: 5px;">Rename</button>
          <button id="deletePresetBtn" style="padding: 5px 12px; background: #e74c3c; color: white; border: none; border-radius: 3px; cursor: pointer;">Delete</button>
          <div class="edit-mode-info" id="presetEditInfo" style="margin-top: 5px;">Click factor sliders to adjust values. Changes save automatically when switching presets or exiting.</div>
        </div>
      </div>
      <div style="flex-shrink: 0;">
        <h3 style="margin: 0 0 10px 0; color: #2c3e50; font-size: 0.9em;">Situational Factors</h3>
        <div class="factors-equalizer">
      <div class="factor-slider">
        <div class="bar-container">
          <div class="bar-fill" id="bar-expertise" style="height: 0%;"></div>
        </div>
        <div class="factor-value" id="value-expertise">-</div>
  <input type="number" min="0" max="100" step="1" class="factor-input" id="input-expertise" value="" disabled />
        <label for="bar-expertise">Human Expertise</label>
      </div>
      <div class="factor-slider">
        <div class="bar-container">
          <div class="bar-fill" id="bar-aicapability" style="height: 0%;"></div>
        </div>
        <div class="factor-value" id="value-aicapability">-</div>
  <input type="number" min="0" max="100" step="1" class="factor-input" id="input-aicapability" value="" disabled />
        <label for="bar-aicapability">AI Capability</label>
      </div>
      <div class="factor-slider">
        <div class="bar-container">
          <div class="bar-fill" id="bar-governance" style="height: 0%;"></div>
        </div>
        <div class="factor-value" id="value-governance">-</div>
  <input type="number" min="0" max="100" step="1" class="factor-input" id="input-governance" value="" disabled />
        <label for="bar-governance">Governance & Safety</label>
      </div>
    </div>
      </div>
    </div>
  </div>
  
  <div class="preset-controls">
    <h3 class="panel-header" id="scenarioPanelHeader">
      <span class="panel-title">Scenarios</span>
      <button class="collapse-btn" id="scenarioCollapseBtn">−</button>
    </h3>
    <div class="panel-content preset-panel-layout" id="scenarioPanelContent">
      <div style="flex: 1;">
        <div style="display: flex; align-items: flex-start; gap: 8px;">
          <button class="add-btn" id="addScenarioBtn" title="Create a new scenario" style="display: none;">+</button>
          <div class="preset-buttons" id="scenarioButtonsContainer" style="display: flex; gap: 8px; flex-wrap: wrap; flex: 1;">
            <!-- Scenario buttons will be dynamically generated here -->
          </div>
        </div>
        <div id="scenarioEmptyMessage" style="display: none; padding: 10px 0; color: #666; font-style: italic;">
          No scenarios available. Press "+" to create a scenario.
        </div>
        <div id="scenarioEditControls" style="display:none; margin-top: 10px;">
          <button id="renameScenarioBtn" style="padding: 5px 12px; background: #3498db; color: white; border: none; border-radius: 3px; cursor: pointer; margin-right: 5px;">Rename</button>
          <button id="deleteScenarioBtn" style="padding: 5px 12px; background: #e74c3c; color: white; border: none; border-radius: 3px; cursor: pointer;">Delete</button>
          <div class="edit-mode-info" id="scenarioEditInfo" style="margin-top: 5px;">Click cells to create workflow path. Click factor sliders to adjust values. Changes save automatically.</div>
        </div>
      </div>
      <div style="flex-shrink: 0;">
        <h3 style="margin: 0 0 10px 0; color: #2c3e50; font-size: 0.9em;">Situational Factors</h3>
        <div class="factors-equalizer">
      <div class="factor-slider">
        <div class="bar-container">
          <div class="bar-fill" id="bar-scenario-importance" style="height: 0%;"></div>
        </div>
        <div class="factor-value" id="value-scenario-importance">-</div>
  <input type="number" min="0" max="100" step="1" class="factor-input" id="input-scenario-importance" value="" disabled />
        <label for="bar-scenario-importance">Task Importance</label>
      </div>
      <div class="factor-slider">
        <div class="bar-container">
          <div class="bar-fill" id="bar-scenario-complexity" style="height: 0%;"></div>
        </div>
        <div class="factor-value" id="value-scenario-complexity">-</div>
  <input type="number" min="0" max="100" step="1" class="factor-input" id="input-scenario-complexity" value="" disabled />
        <label for="bar-scenario-complexity">Task Complexity</label>
      </div>
      <div class="factor-slider">
        <div class="bar-container">
          <div class="bar-fill" id="bar-scenario-maturity" style="height: 0%;"></div>
        </div>
        <div class="factor-value" id="value-scenario-maturity">-</div>
  <input type="number" min="0" max="100" step="1" class="factor-input" id="input-scenario-maturity" value="" disabled />
        <label for="bar-scenario-maturity">Codebase Maturity</label>
      </div>
    </div>
      </div>
    </div>
  </div>
  
  <div class="product-selector">
    <h3 class="panel-header" id="productPanelHeader">
      <span class="panel-title">Product Capabilities</span>
      <button class="collapse-btn" id="productCollapseBtn">−</button>
    </h3>
    <div class="panel-content" id="productPanelContent">
      <div style="display: flex; align-items: center; gap: 8px;">
        <div class="product-buttons" id="productButtonsContainer" style="display: flex; gap: 8px; flex-wrap: wrap; flex: 1;">
        <!-- Product buttons will be dynamically generated here -->
        </div>
        <button class="edit-icon-btn" id="editModeToggle" title="Edit Product Capabilities">✏️</button>
      </div>
      <div id="productEditControls" style="display:none; margin-top: 10px;">
        <button id="exitProductEditBtn" style="padding: 5px 12px; background: #95a5a6; color: white; border: none; border-radius: 3px; cursor: pointer; margin-right: 5px;">Exit</button>
        <button id="renameProductBtn" style="padding: 5px 12px; background: #3498db; color: white; border: none; border-radius: 3px; cursor: pointer; margin-right: 5px;">Rename</button>
        <button id="deleteProductBtn" style="padding: 5px 12px; background: #e74c3c; color: white; border: none; border-radius: 3px; cursor: pointer;">Delete</button>
        <div class="edit-mode-info" id="editModeInfo" style="margin-top: 5px;">Click cells to select capabilities. Changes save automatically when switching products or exiting.</div>
      </div>
    </div>
  </div>
  
  <div style="position: relative;">
    <canvas id="presetCanvas" class="preset-canvas"></canvas>
    <table id="uxTable">
      <thead>
        <tr>
          <th></th>
          <th>Code Focused</th>
          <th>Intent Focused</th>
          <th>Orchestration Focused</th>
        </tr>
      </thead>
      <tbody>
        <tr><th>Tool</th><td></td><td></td><td></td></tr>
        <tr><th>Advisor</th><td></td><td></td><td></td></tr>
        <tr><th>Co-Creator</th><td></td><td></td><td></td></tr>
        <tr><th>Team-Mate</th><td></td><td></td><td></td></tr>
        <tr><th>Delegate</th><td></td><td></td><td></td></tr>
      </tbody>
    </table>
  </div>

  <script src="data-transform.js"></script>
  <script src="api-client.js"></script>
  <script>
    console.log('=== SCRIPT STARTING ===');
    
const data = {
  // ... (keeping the existing data structure)
  "Tool": {
    "Code Focused": {
      "signature": "Local, reactive, low autonomy; optimised for incremental assist.",
      "sentences": [
        "<strong>Set Context:</strong> Context inferred from current artefact; minimal explicit setup.",
        "<strong>Generate/Act:</strong> AI responds to micro-signals; outputs small increments.",
        "<strong>Evaluate:</strong> Quick inline review; accept or ignore instantly.",
        "<strong>Repair/Refine:</strong> Adjust by editing or adding hints; iteration is manual.",
        "<strong>Apply/Ship:</strong> Integrated through normal workflow; no orchestration layer."
      ],
      "detail": "Context is inferred from the current artefact and recent actions. AI reacts to immediate signals with small, context-aware outputs. Human reviews and integrates outputs quickly, making manual refinements as needed. This mode prioritises speed and flow, with minimal trust barriers and no additional orchestration."
    },
    "Intent Focused": {
      "signature": "Reactive to stated goals; bridges natural language and structured outputs.",
      "sentences": [
        "<strong>Set Context:</strong> Context comes from explicit goals or task descriptions.",
        "<strong>Generate/Act:</strong> AI generates outputs aligned to stated intent.",
        "<strong>Evaluate:</strong> Human checks alignment with objectives and constraints.",
        "<strong>Repair/Refine:</strong> Refinement happens by rephrasing or clarifying intent.",
        "<strong>Apply/Ship:</strong> Outputs integrated into workflow after validation."
      ],
      "detail": "Human provides explicit goals or instructions in natural language or structured prompts. AI interprets these and generates outputs aligned with intent. Evaluation focuses on whether outputs meet objectives. Refinement occurs through rephrasing or clarifying goals. Integration follows standard processes."
    },
    "Orchestration Focused": {
      "signature": "Reactive coordination; supports multi-step workflows without autonomy.",
      "sentences": [
        "<strong>Set Context:</strong> Context defined by workflow steps or orchestration scripts.",
        "<strong>Generate/Act:</strong> AI executes discrete tasks within a larger process.",
        "<strong>Evaluate:</strong> Human validates each step before proceeding.",
        "<strong>Repair/Refine:</strong> Refinement involves adjusting workflow parameters.",
        "<strong>Apply/Ship:</strong> Outputs combined into the orchestrated system manually."
      ],
      "detail": "Human defines workflow steps or orchestration scripts. AI executes individual tasks but does not self-direct. Human validates outputs at each stage and adjusts parameters as needed. Integration happens within the orchestrated system, requiring human oversight for sequencing and dependencies."
    }
  },
  "Advisor": {
    "Code Focused": {
      "signature": "Choice-oriented, human-in-control; ideal for trust-building and compliance-heavy work.",
      "sentences": [
        "<strong>Set Context:</strong> Provide richer hints or annotations to frame options.",
        "<strong>Generate/Act:</strong> AI proposes multiple alternatives for comparison.",
        "<strong>Evaluate:</strong> Human weighs trade-offs; higher cognitive load than Tool mode.",
        "<strong>Repair/Refine:</strong> Request new options or tweak framing for better fit.",
        "<strong>Apply/Ship:</strong> Manual integration; standard validation applies."
      ],
      "detail": "Human frames the problem with richer hints or annotations. AI generates multiple alternatives, leaving selection to the human. Evaluation involves comparing trade-offs like efficiency or clarity. Refinement occurs through iterative requests for new options. Integration remains manual, with standard validation."
    },
    "Intent Focused": {
      "signature": "Goal-driven suggestions; supports decision-making without full automation.",
      "sentences": [
        "<strong>Set Context:</strong> Context comes from high-level goals or desired outcomes.",
        "<strong>Generate/Act:</strong> AI offers alternative strategies or plans.",
        "<strong>Evaluate:</strong> Human evaluates feasibility and alignment with objectives.",
        "<strong>Repair/Refine:</strong> Refinement involves clarifying priorities or constraints.",
        "<strong>Apply/Ship:</strong> Chosen approach integrated into workflow manually."
      ],
      "detail": "Human specifies goals or desired outcomes. AI suggests alternative strategies or plans, leaving decision-making to the human. Evaluation focuses on feasibility and alignment. Refinement occurs by clarifying priorities or constraints. Integration is manual, ensuring human control."
    },
    "Orchestration Focused": {
      "signature": "Advisory role in complex workflows; human retains orchestration control.",
      "sentences": [
        "<strong>Set Context:</strong> Context defined by multi-agent or multi-step objectives.",
        "<strong>Generate/Act:</strong> AI suggests orchestration patterns or task allocations.",
        "<strong>Evaluate:</strong> Human validates and selects orchestration strategy.",
        "<strong>Repair/Refine:</strong> Refinement involves adjusting dependencies or sequencing.",
        "<strong>Apply/Ship:</strong> Integration requires manual coordination across systems."
      ],
      "detail": "Human defines multi-step objectives. AI advises on orchestration strategies, such as task allocation or sequencing. Human validates and selects the approach. Refinement involves adjusting dependencies or constraints. Integration requires manual coordination across systems."
    }
  },
  "Co-Creator": {
    "Code Focused": {
      "signature": "Collaborative, high-context, medium autonomy; accelerates creative work.",
      "sentences": [
        "<strong>Set Context:</strong> Supply partial structure or examples to guide AI.",
        "<strong>Generate/Act:</strong> AI contributes substantial components within human direction.",
        "<strong>Evaluate:</strong> Review for correctness and alignment with goals.",
        "<strong>Repair/Refine:</strong> Iterative back-and-forth; conversational adjustments.",
        "<strong>Apply/Ship:</strong> Merge after validation; fits into existing delivery pipeline."
      ],
      "detail": "Human provides partial structure or examples. AI generates substantial components, guided by human direction. Evaluation ensures correctness and alignment. Refinement occurs through iterative, conversational adjustments. Outputs are integrated after validation."
    },
    "Intent Focused": {
      "signature": "Shared authorship; human sets intent, AI fills in details.",
      "sentences": [
        "<strong>Set Context:</strong> Context comes from detailed goals or scenarios.",
        "<strong>Generate/Act:</strong> AI drafts plans or artefacts aligned with intent.",
        "<strong>Evaluate:</strong> Human reviews for completeness and relevance.",
        "<strong>Repair/Refine:</strong> Refinement through iterative clarification of goals.",
        "<strong>Apply/Ship:</strong> Outputs integrated into broader workflow after review."
      ],
      "detail": "Human provides detailed goals or scenarios. AI drafts plans or artefacts aligned with intent. Human reviews for completeness and relevance. Refinement occurs through iterative clarification. Integration follows standard workflows."
    },
    "Orchestration Focused": {
      "signature": "Collaborative orchestration; AI manages sub-tasks under human guidance.",
      "sentences": [
        "<strong>Set Context:</strong> Context defined by overarching objectives and constraints.",
        "<strong>Generate/Act:</strong> AI proposes orchestration plans and executes sub-tasks.",
        "<strong>Evaluate:</strong> Human monitors progress and validates milestones.",
        "<strong>Repair/Refine:</strong> Refinement involves adjusting orchestration logic.",
        "<strong>Apply/Ship:</strong> Outputs integrated into the system after milestone checks."
      ],
      "detail": "Human defines overarching objectives and constraints. AI proposes orchestration plans and executes sub-tasks. Human monitors progress and validates milestones. Refinement involves adjusting orchestration logic. Outputs are integrated after milestone checks."
    }
  },
  "Team-Mate": {
    "Code Focused": {
      "signature": "Goal-driven, semi-autonomous; mirrors human team dynamics.",
      "sentences": [
        "<strong>Set Context:</strong> Define objectives and constraints at a higher level.",
        "<strong>Generate/Act:</strong> AI drafts across multiple artefacts; human monitors.",
        "<strong>Evaluate:</strong> Oversight similar to reviewing a colleague’s work.",
        "<strong>Repair/Refine:</strong> Feedback via structured comments or edits; AI iterates.",
        "<strong>Apply/Ship:</strong> Integration after thorough review and testing."
      ],
      "detail": "Human defines objectives and constraints. AI drafts across multiple artefacts, with human oversight. Evaluation mirrors reviewing a colleague’s work. Refinement occurs through structured feedback. Integration follows thorough review and testing."
    },
    "Intent Focused": {
      "signature": "Semi-autonomous execution; human provides goals, AI plans and acts.",
      "sentences": [
        "<strong>Set Context:</strong> Context comes from high-level goals and constraints.",
        "<strong>Generate/Act:</strong> AI plans steps and executes tasks toward the goal.",
        "<strong>Evaluate:</strong> Human validates progress at checkpoints.",
        "<strong>Repair/Refine:</strong> Refinement involves adjusting goals or priorities.",
        "<strong>Apply/Ship:</strong> Outputs integrated after milestone approval."
      ],
      "detail": "Human provides high-level goals and constraints. AI plans and executes tasks toward the goal. Human validates progress at checkpoints. Refinement occurs by adjusting goals or priorities. Outputs are integrated after milestone approval."
    },
    "Orchestration Focused": {
      "signature": "AI acts as a managed collaborator; executes orchestration plans under oversight.",
      "sentences": [
        "<strong>Set Context:</strong> Context defined by multi-step objectives and dependencies.",
        "<strong>Generate/Act:</strong> AI coordinates agents and resources to achieve goals.",
        "<strong>Evaluate:</strong> Human reviews orchestration outcomes at key stages.",
        "<strong>Repair/Refine:</strong> Refinement involves rebalancing tasks or dependencies.",
        "<strong>Apply/Ship:</strong> Outputs integrated after orchestration validation."
      ],
      "detail": "Human defines multi-step objectives and dependencies. AI coordinates agents and resources to achieve goals. Human reviews orchestration outcomes at key stages. Refinement involves rebalancing tasks or dependencies. Outputs are integrated after validation."
    }
  },
  "Delegate": {
    "Code Focused": {
      "signature": "High autonomy, milestone-driven; ideal for scale and speed under governance.",
      "sentences": [
        "<strong>Set Context:</strong> Specify goals and constraints in structured form.",
        "<strong>Generate/Act:</strong> AI executes large portions independently.",
        "<strong>Evaluate:</strong> Validate outputs at checkpoints, not line-by-line.",
        "<strong>Repair/Refine:</strong> Adjust goals or constraints rather than micro details.",
        "<strong>Apply/Ship:</strong> Integrate after milestone validation and dependency checks."
      ],
      "detail": "Human specifies goals and constraints in structured form. AI executes large portions independently. Human validates outputs at milestones. Refinement occurs at the goal level. Integration follows milestone validation and dependency checks."
    },
    "Intent Focused": {
      "signature": "AI owns execution; human defines intent and validates outcomes.",
      "sentences": [
        "<strong>Set Context:</strong> Context comes from explicit goals and success criteria.",
        "<strong>Generate/Act:</strong> AI autonomously plans and executes tasks.",
        "<strong>Evaluate:</strong> Human validates outputs against objectives.",
        "<strong>Repair/Refine:</strong> Refinement involves redefining goals or constraints.",
        "<strong>Apply/Ship:</strong> Outputs integrated after final approval."
      ],
      "detail": "Human defines explicit goals and success criteria. AI autonomously plans and executes tasks. Human validates outputs against objectives. Refinement occurs by redefining goals or constraints. Outputs are integrated after final approval."
    },
    "Orchestration Focused": {
      "signature": "Full orchestration autonomy; human sets direction and validates milestones.",
      "sentences": [
        "<strong>Set Context:</strong> Context defined by overarching objectives and governance rules.",
        "<strong>Generate/Act:</strong> AI manages orchestration end-to-end across agents and systems.",
        "<strong>Evaluate:</strong> Human validates at major milestones only.",
        "<strong>Repair/Refine:</strong> Refinement involves adjusting governance or objectives.",
        "<strong>Apply/Ship:</strong> Outputs integrated automatically after approval."
      ],
      "detail": "Human defines overarching objectives and governance rules. AI manages orchestration end-to-end across agents and systems. Human validates at major milestones. Refinement occurs by adjusting governance or objectives. Outputs are integrated automatically after approval."
    }
  }
};
    const table = document.getElementById('uxTable');
    const presetCanvas = document.getElementById('presetCanvas');
    const presetCtx = presetCanvas.getContext('2d');
  let currentPreset = null;
  let currentScenario = null;
  let currentProduct = null;
    let activeCell = null;
    let flyoutTimer = null;

    for (let row of table.rows) {
      for (let cell of row.cells) {
        if (cell.cellIndex === 0 || row.rowIndex === 0) continue;
        const rowLabel = table.rows[cell.parentNode.rowIndex].cells[0].textContent;
        const colLabel = table.rows[0].cells[cell.cellIndex].textContent;
        const cellData = data[rowLabel]?.[colLabel];
        if (!cellData) continue;

        cell.innerHTML = `<span class="cell-content">${cellData.signature}</span><div class="cell-detail" style="display: block;">${cellData.sentences.join('<br>')}</div><div class="flyout">${cellData.detail}</div>`;

        cell.addEventListener('mouseenter', () => {
          if (activeCell && activeCell !== cell) {
            activeCell.classList.remove('expanded');
            activeCell.querySelector('.flyout').style.display = 'none';
            clearTimeout(flyoutTimer);
          }
          cell.classList.add('expanded');
          flyoutTimer = setTimeout(() => {
            const flyout = cell.querySelector('.flyout');
            const isLastRow = cell.parentNode.rowIndex === table.rows.length - 1;
            if (isLastRow) {
              flyout.style.top = 'auto';
              flyout.style.bottom = '100%';
              flyout.style.marginTop = '0';
              flyout.style.marginBottom = '5px';
            } else {
              flyout.style.top = '100%';
              flyout.style.bottom = 'auto';
              flyout.style.marginTop = '5px';
              flyout.style.marginBottom = '0';
            }
            flyout.style.display = 'block';
          }, 1000);
          activeCell = cell;
        });

        cell.addEventListener('mouseleave', () => {
          clearTimeout(flyoutTimer);
          cell.classList.remove('expanded');
          cell.querySelector('.flyout').style.display = 'none';
        });
      }
    }

    // Initialize canvas size
    function resizeCanvas() {
      const tableRect = table.getBoundingClientRect();
      presetCanvas.width = tableRect.width;
      presetCanvas.height = tableRect.height;
    }
    
    function redrawCurrentWorkflow() {
      // Redraw workflow if both preset and scenario are selected
      if (currentPreset && currentScenario) {
        drawWorkflow(currentPreset, currentScenario);
      }
    }
    
    resizeCanvas();
    window.addEventListener('resize', () => {
      resizeCanvas();
      redrawCurrentWorkflow();
    });

    // Workflow visualization functions
    function drawWorkflow(presetKey, scenarioKey) {
      currentPreset = presetKey;
      currentScenario = scenarioKey;
      clearPresetVisualization();
      
      // Look up workflow using composite key "preset:scenario"
      const workflowKey = `${presetKey}:${scenarioKey}`;
      const workflow = workflows[workflowKey] || [];
      if (workflow.length === 0) return;

      // Clear existing dots
      document.querySelectorAll('.preset-dot').forEach(dot => dot.remove());
      document.querySelectorAll('td.preset-selected').forEach(cell => cell.classList.remove('preset-selected'));

      const points = [];
      
      // Create dots and collect points
      workflow.forEach(([role, focus], index) => {
        const cell = findCell(role, focus);
        if (cell) {
          cell.classList.add('preset-selected');
          
          // Create dot
          const dot = document.createElement('div');
          dot.className = 'preset-dot';
          dot.textContent = index + 1;
          
          const cellRect = cell.getBoundingClientRect();
          const tableRect = table.getBoundingClientRect();
          
          const x = cellRect.left - tableRect.left + cellRect.width / 2;
          const y = cellRect.top - tableRect.top + cellRect.height / 2;
          
          dot.style.left = (x - 10) + 'px';
          dot.style.top = (y - 10) + 'px';
          
          table.parentElement.appendChild(dot);
          
          points.push({ x, y });
        }
      });

      // Draw lines connecting the dots
      if (points.length > 1) {
        presetCtx.clearRect(0, 0, presetCanvas.width, presetCanvas.height);
        presetCtx.strokeStyle = '#9b59b6';
        presetCtx.lineWidth = 3;
        presetCtx.setLineDash([5, 5]);
        presetCtx.lineCap = 'round';
        presetCtx.lineJoin = 'round';

        // Draw curved lines between points
        for (let i = 0; i < points.length - 1; i++) {
          const p1 = points[i];
          const p2 = points[i + 1];
          
          // Calculate control points for quadratic curve
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          // Create a curve that bends perpendicular to the line
          // The amount of curve is proportional to the distance
          const curvature = Math.min(distance * 0.3, 50);
          
          // Calculate perpendicular direction
          const perpX = -dy / distance;
          const perpY = dx / distance;
          
          // Control point is offset perpendicular to the line
          const controlX = (p1.x + p2.x) / 2 + perpX * curvature;
          const controlY = (p1.y + p2.y) / 2 + perpY * curvature;
          
          presetCtx.beginPath();
          presetCtx.moveTo(p1.x, p1.y);
          presetCtx.quadraticCurveTo(controlX, controlY, p2.x, p2.y);
          presetCtx.stroke();
        }
      }
    }

    function clearPresetVisualization() {
      presetCtx.clearRect(0, 0, presetCanvas.width, presetCanvas.height);
      document.querySelectorAll('.preset-dot').forEach(dot => dot.remove());
      document.querySelectorAll('td.preset-selected').forEach(cell => cell.classList.remove('preset-selected'));
      // Note: Do not clear currentPreset here - that should be managed by the caller
    }

    // Product capability mapping
    const defaultProductCapabilities = {
      'github-copilot': [
        ['Tool', 'Code Focused'],
        ['Advisor', 'Code Focused'],
        ['Co-Creator', 'Code Focused']
      ],
      'spec-kit': [
        ['Advisor', 'Intent Focused'],
        ['Co-Creator', 'Intent Focused'],
        ['Team-Mate', 'Intent Focused']
      ],
      'cursor': [
        ['Tool', 'Code Focused'],
        ['Co-Creator', 'Code Focused'],
        ['Team-Mate', 'Code Focused']
      ],
      'claude': [
        ['Advisor', 'Intent Focused'],
        ['Co-Creator', 'Intent Focused'],
        ['Team-Mate', 'Intent Focused'],
        ['Delegate', 'Intent Focused']
      ],
      'copilot-agents': [
        ['Co-Creator', 'Intent Focused'],
        ['Team-Mate', 'Intent Focused']
      ]
    };
    
    // Default product display names
    const defaultProductMetadata = {
      'github-copilot': 'GitHub Copilot Completions, NES',
      'spec-kit': 'spec-kit',
      'cursor': 'Cursor IDE',
      'claude': 'Claude',
      'copilot-agents': 'GitHub Copilot Agent Mode'
    };

    // Initialize product data as empty objects (will be populated from API)
    const productCapabilities = {};
    const productMetadata = {};

    // Default preset workflows (REMOVED - now in scenarios)
    const defaultPresets = {
      'enterprise-maintainer': [],
      'ai-native-product-maker': [],
      'domain-expert-orchestrator': []
    };

    // Situational factors for each preset (0-100 scale) - Only 3 factors now
    // Higher values = more of that factor
    const defaultPresetFactors = {
      'enterprise-maintainer': {
        expertise: 75,       // High expertise - seasoned professional
        aicapability: 60,    // Moderate AI capability - balanced approach
        governance: 85       // High governance - enterprise standards
      },
      'ai-native-product-maker': {
        expertise: 65,       // Good expertise - product focused
        aicapability: 90,    // Very high AI capability - AI-first approach
        governance: 40       // Lower governance - innovation focused
      },
      'domain-expert-orchestrator': {
        expertise: 80,       // Very high expertise - domain authority
        aicapability: 70,    // Good AI capability - orchestration tools
        governance: 60       // Moderate governance - balanced oversight
      }
    };

    // Default preset display names
    const defaultPresetMetadata = {
      'enterprise-maintainer': 'Enterprise Maintainer',
      'ai-native-product-maker': 'AI-Native Product-Maker',
      'domain-expert-orchestrator': 'Domain Expert Orchestrator'
    };

    // Default workflows - keyed by "preset:scenario" combinations
    // Workflows are unique to each preset+scenario pair
    const defaultWorkflows = {
      'enterprise-maintainer:prototyping': [],
      'ai-native-product-maker:prototyping': [],
      'domain-expert-orchestrator:prototyping': []
      // More preset:scenario combinations can be added as users create them
    };

    // Scenario factors are ALSO keyed by "preset:scenario" combinations
    // Different presets can have different factor values for the same scenario
    const defaultScenarioFactors = {
      'enterprise-maintainer:prototyping': {
        importance: 50,
        complexity: 50,
        maturity: 50
      },
      'ai-native-product-maker:prototyping': {
        importance: 50,
        complexity: 50,
        maturity: 50
      },
      'domain-expert-orchestrator:prototyping': {
        importance: 50,
        complexity: 50,
        maturity: 50
      }
    };

    // Scenario metadata is now PRESET-SPECIFIC
    // Each preset has its own list of scenarios
    const defaultScenarioMetadata = {
      'enterprise-maintainer': {
        'prototyping': 'Prototyping'
      },
      'ai-native-product-maker': {
        'prototyping': 'Prototyping'
      },
      'domain-expert-orchestrator': {
        'prototyping': 'Prototyping'
      }
      // Each preset must have at least one scenario (prototyping with factors=50)
    };

    // Initialize state objects as empty (will be populated from API)
    const presets = {};
    const presetFactors = {};
    const presetMetadata = {};
    const workflows = {};
    const scenarioFactors = {};
    const scenarioMetadata = {};
    
    // Data validation is no longer needed - data comes from API
    // All initialization happens in DOMContentLoaded event handler

    // Save functions now use API instead of localStorage
    async function savePresets() {
      // Presets are saved individually when edited
      // This function is kept for compatibility but doesn't need to do anything
      console.log('Presets are auto-saved to database');
    }

    async function saveWorkflows() {
      // Workflows are saved individually when edited
      // This function is kept for compatibility but doesn't need to do anything
      console.log('Workflows are auto-saved to database');
    }

    async function saveProductCapabilities() {
      // Products are saved individually when edited
      // This function is kept for compatibility but doesn't need to do anything
      console.log('Product capabilities are auto-saved to database');
    }

    // Load functions - these are now called from the initialization
    function loadPresets() {
      // Data is loaded from API on page load
      return presets;
    }
    
    function loadPresetFactors() {
      return presetFactors;
    }
    
    function loadPresetMetadata() {
      return presetMetadata;
    }

    function loadWorkflows() {
      return workflows;
    }
    
    function loadScenarioFactors() {
      return scenarioFactors;
    }
    
    function loadScenarioMetadata() {
      return scenarioMetadata;
    }

    function loadProductCapabilities() {
      return productCapabilities;
    }
    
    function loadProductMetadata() {
      return productMetadata;
    }
    
    // Initialize product UI - generate buttons from database
    function initializeProductUI(autoSelect = false) {
      const productButtonsContainer = document.getElementById('productButtonsContainer');

      const existingButtons = productButtonsContainer.querySelectorAll('.product-btn');
      existingButtons.forEach(btn => btn.remove());

      let firstProductKey = null;

      Object.keys(productCapabilities).forEach((productKey, index) => {
        if (index === 0) {
          firstProductKey = productKey;
        }

        const btn = document.createElement('button');
        btn.className = 'product-btn';
        btn.dataset.product = productKey;
        btn.textContent = productMetadata[productKey] || productKey;

        btn.addEventListener('click', async () => {
          await handleProductSelection(productKey, btn);
        });

        if (currentProduct === productKey) {
          btn.classList.add('active');
        }

        productButtonsContainer.appendChild(btn);
      });

      if (productEditMode) {
        ensureProductAddButton();
      }

      const existingActiveBtn = currentProduct
        ? productButtonsContainer.querySelector(`[data-product="${currentProduct}"]`)
        : null;

      if (existingActiveBtn) {
        if (productEditMode) {
          activateProductEditingForCurrentProduct({ preserveSelection: true });
        } else {
          highlightProductCapabilities(currentProduct);
        }
      } else if (autoSelect && firstProductKey) {
        const firstBtn = productButtonsContainer.querySelector(`[data-product="${firstProductKey}"]`);
        if (firstBtn) {
          handleProductSelection(firstProductKey, firstBtn, { skipSave: true, autoSelect: true }).catch(error => {
            console.error('Auto-select product failed:', error);
          });
        }
      } else if (!productEditMode) {
        clearProductHighlights();
      }
    }

    // Product button event handlers
    // (Buttons are now dynamically generated in initializeProductUI)

    function findCell(role, focus) {
      for (let row of table.rows) {
        if (row.cells[0].textContent === role) {
          for (let cell of row.cells) {
            const colLabel = table.rows[0].cells[cell.cellIndex].textContent;
            if (colLabel === focus) {
              return cell;
            }
          }
        }
      }
      return null;
    }

    // Function to update factor sliders for presets (only 3 factors now)
    function updateFactorSliders(presetKey) {
      const factors = presetFactors[presetKey];
      if (!factors) return;

      const factorNames = ['expertise', 'aicapability', 'governance'];
      
      factorNames.forEach(name => {
        const bar = document.getElementById(`bar-${name}`);
        const valueDisplay = document.getElementById(`value-${name}`);
        const input = document.getElementById(`input-${name}`);
        const value = factors[name];
        
        if (bar && valueDisplay) {
          // Get current height percentage
          const currentHeight = parseFloat(bar.style.height) || 0;
          const targetHeight = value;
          const duration = 500; // milliseconds
          const startTime = performance.now();
          
          function animate(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // Ease-out animation
            const easeProgress = 1 - Math.pow(1 - progress, 3);
            const currentValue = Math.round(currentHeight + (targetHeight - currentHeight) * easeProgress);
            
            bar.style.height = currentValue + '%';
            valueDisplay.textContent = currentValue;
            if (input) {
              input.value = currentValue;
            }
            
            if (progress < 1) {
              requestAnimationFrame(animate);
            }
          }
          
          requestAnimationFrame(animate);
        }
      });
    }

    // Function to update factor sliders for scenarios (3 different factors)
    // Function to update factor sliders for scenarios (3 different factors)
    // Now requires BOTH preset and scenario keys to look up the composite factor values
    function updateScenarioFactorSliders(presetKey, scenarioKey) {
      // Use composite key "preset:scenario" to look up factors
      const compositeKey = `${presetKey}:${scenarioKey}`;
      const factors = scenarioFactors[compositeKey];
      if (!factors) return;

      const factorNames = ['importance', 'complexity', 'maturity'];
      
      factorNames.forEach(name => {
        const bar = document.getElementById(`bar-scenario-${name}`);
        const valueDisplay = document.getElementById(`value-scenario-${name}`);
        const input = document.getElementById(`input-scenario-${name}`);
        const value = factors[name];
        
        if (bar && valueDisplay) {
          const currentHeight = parseFloat(bar.style.height) || 0;
          const targetHeight = value;
          const duration = 500;
          const startTime = performance.now();
          
          function animate(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            const easeProgress = 1 - Math.pow(1 - progress, 3);
            const currentValue = Math.round(currentHeight + (targetHeight - currentHeight) * easeProgress);
            
            bar.style.height = currentValue + '%';
            valueDisplay.textContent = currentValue;
            if (input) {
              input.value = currentValue;
            }
            
            if (progress < 1) {
              requestAnimationFrame(animate);
            }
          }
          
          requestAnimationFrame(animate);
        }
      });
    }

    // Function to clear factor sliders
    function clearFactorSliders() {
      const factorConfigs = [
        { barId: 'bar-expertise', valueId: 'value-expertise', inputId: 'input-expertise' },
        { barId: 'bar-aicapability', valueId: 'value-aicapability', inputId: 'input-aicapability' },
        { barId: 'bar-governance', valueId: 'value-governance', inputId: 'input-governance' },
        { barId: 'bar-scenario-importance', valueId: 'value-scenario-importance', inputId: 'input-scenario-importance' },
        { barId: 'bar-scenario-complexity', valueId: 'value-scenario-complexity', inputId: 'input-scenario-complexity' },
        { barId: 'bar-scenario-maturity', valueId: 'value-scenario-maturity', inputId: 'input-scenario-maturity' }
      ];
      
      factorConfigs.forEach(({ barId, valueId, inputId }) => {
        const bar = document.getElementById(barId);
        const valueDisplay = document.getElementById(valueId);
        const input = document.getElementById(inputId);
        
        if (bar && valueDisplay) {
          const currentHeight = parseFloat(bar.style.height) || 0;
          const targetHeight = 0;
          const duration = 500;
          const startTime = performance.now();
          
          function animate(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            const easeProgress = 1 - Math.pow(1 - progress, 3);
            const currentValue = Math.round(currentHeight + (targetHeight - currentHeight) * easeProgress);
            
            bar.style.height = currentValue + '%';
            
            if (progress >= 1) {
              valueDisplay.textContent = '-';
              if (input) {
                input.value = '';
              }
            } else {
              valueDisplay.textContent = currentValue;
              if (input) {
                input.value = currentValue;
              }
            }
            
            if (progress < 1) {
              requestAnimationFrame(animate);
            }
          }
          
          requestAnimationFrame(animate);
        }
      });
    }

    // Function to initialize preset buttons from loaded data
    function initializePresetUI(autoSelect = false) {
      const presetButtonsContainer = document.querySelector('.preset-buttons');
      const presetEmptyMessage = document.getElementById('presetEmptyMessage');
      
      // Clear existing preset buttons
      const existingPresetBtns = presetButtonsContainer.querySelectorAll('.preset-btn');
      existingPresetBtns.forEach(btn => btn.remove());
      
      // Check if we have any presets
      if (Object.keys(presets).length === 0) {
        console.warn('No presets available. Please create a preset using the + button.');
        presetEmptyMessage.style.display = 'block';
        return;
      }
      
      // Hide empty message when presets exist
      presetEmptyMessage.style.display = 'none';
      
      let firstPresetKey = null;
      
      // Add buttons and dropdown options for each preset
      Object.keys(presets).forEach((presetKey, index) => {
        if (index === 0) firstPresetKey = presetKey;
        
        // Get display name from metadata or generate from key
        const displayName = presetMetadata[presetKey] || presetKey.split('-').map(word => 
          word.charAt(0).toUpperCase() + word.slice(1)
        ).join(' ');
        
        // Create button
        const presetBtn = document.createElement('button');
        presetBtn.className = 'preset-btn';
        presetBtn.dataset.preset = presetKey;
        presetBtn.textContent = displayName;
        
        // Add click handler
        presetBtn.addEventListener('click', async () => {
          const preset = presetBtn.dataset.preset;

          if (preset === currentPreset) {
            return;
          }
          
          console.log('Preset button clicked:', preset);

          const previousPreset = currentPreset;
          const previousScenario = currentScenario;

          if (presetEditMode && previousPreset && previousPreset !== preset && previousScenario) {
            const scenarioSaved = await persistScenarioChangesOrWarn('switch-preset');
            if (!scenarioSaved) {
              return;
            }
          }
          
          // If in edit mode and switching presets, auto-save the current preset
          if (presetEditMode && previousPreset && previousPreset !== preset && presetFactors[previousPreset]) {
            try {
              const profileData = DataTransform.frontendProfileToDb(previousPreset, presetFactors, presetMetadata);
              await API.updateProfile(previousPreset, profileData);
              console.log(`Preset ${previousPreset} auto-saved on switch`);
            } catch (error) {
              console.error('Failed to auto-save preset:', error);
              // Don't block the switch, just log the error
            }
          }
          
          // Clear active states for preset buttons only (within preset container)
          presetButtonsContainer.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
          
          // Set active button
          presetBtn.classList.add('active');
          
          // Update currentPreset
          currentPreset = preset;
          
          console.log('currentPreset set to:', currentPreset);
          
          // Update preset factor sliders
          updateFactorSliders(preset);
          
          // Clear scenario selection when changing presets
          currentScenario = null;
          clearPresetVisualization();

          deactivateScenarioEditingUI();
          resetScenarioDirtyFlags();
          clearScenarioFactorDisplay();

          tempScenarioSelections = [];
          
          console.log('About to call initializeScenarioUI, currentPreset is:', currentPreset);
          
          // Reinitialize scenario UI to show scenarios for this preset
          initializeScenarioUI(true); // Auto-select first scenario
          
          // Update collapsed panel title if needed
          updateCollapsedPanelTitle('Profile Presets');
        });
        
        // Add to container
        presetButtonsContainer.appendChild(presetBtn);
      });
      
      // Auto-select first preset if requested (on page load)
      if (autoSelect && firstPresetKey) {
        const firstBtn = presetButtonsContainer.querySelector(`[data-preset="${firstPresetKey}"]`);
        if (firstBtn) {
          firstBtn.classList.add('active');
          currentPreset = firstPresetKey;
          updateFactorSliders(firstPresetKey);
          // Don't draw workflow yet - wait for scenario to be selected
        }
      }
    }

    // Function to initialize scenario UI
    function initializeScenarioUI(autoSelect = false) {
      const scenarioButtonsContainer = document.getElementById('scenarioButtonsContainer');
      const scenarioEmptyMessage = document.getElementById('scenarioEmptyMessage');
      
      // Clear existing scenario buttons AND empty state messages
      const existingScenarioBtns = scenarioButtonsContainer.querySelectorAll('.scenario-btn');
      existingScenarioBtns.forEach(btn => btn.remove());
      const existingEmptyMessages = scenarioButtonsContainer.querySelectorAll('.empty-state-message');
      existingEmptyMessages.forEach(msg => msg.remove());
      
      // Hide empty message by default
      scenarioEmptyMessage.style.display = 'none';
      
      // Must have a preset selected to show scenarios
      if (!currentPreset) {
        console.log('No preset selected, cannot show scenarios');
        currentScenario = null;
        tempScenarioSelections = [];
        clearPresetVisualization();
        clearScenarioFactorDisplay();
        deactivateScenarioEditingUI();
        return; // No scenarios to show without a preset
      }
      
      console.log('Loading scenarios for preset:', currentPreset);
      
      // Get scenarios for the current preset only
      const presetScenarios = scenarioMetadata[currentPreset] || {};
      
      console.log('Found scenarios:', presetScenarios);
      
      // If no scenarios exist for this preset, show a helpful message
      if (Object.keys(presetScenarios).length === 0) {
        console.log('No scenarios found for this preset');
        
        // Show the empty message
        scenarioEmptyMessage.style.display = 'block';
        currentScenario = null;
        tempScenarioSelections = [];
        resetScenarioDirtyFlags();
        clearPresetVisualization();
        clearScenarioFactorDisplay();
        deactivateScenarioEditingUI();
        
        return; // Don't auto-create scenarios
      }
      
      let firstScenarioKey = null;
      
      // Add buttons and dropdown options for scenarios belonging to current preset
      Object.keys(presetScenarios).forEach((scenarioKey, index) => {
        console.log('Creating scenario button:', scenarioKey, presetScenarios[scenarioKey]);
        if (index === 0) firstScenarioKey = scenarioKey;
        
        const displayName = presetScenarios[scenarioKey];
        
        // Create button
        const scenarioBtn = document.createElement('button');
        scenarioBtn.className = 'preset-btn scenario-btn';
        scenarioBtn.dataset.scenario = scenarioKey;
        scenarioBtn.textContent = displayName;
        
        // Add click handler - allows toggling and saving when necessary
        scenarioBtn.addEventListener('click', async () => {
          await handleScenarioSelection(scenarioKey, scenarioBtn);
        });
        
        // Add to container
        scenarioButtonsContainer.appendChild(scenarioBtn);
      });
      
      // Auto-select first scenario if requested (on page load) and preset is selected
      if (autoSelect && firstScenarioKey && currentPreset) {
        const firstBtn = scenarioButtonsContainer.querySelector(`[data-scenario="${firstScenarioKey}"]`);
        if (firstBtn) {
          handleScenarioSelection(firstScenarioKey, firstBtn, { skipSave: true, autoSelect: true }).catch(error => {
            console.error('Auto-select scenario failed:', error);
          });
        }
      }
    }
    
    async function handleScenarioSelection(scenarioKey, scenarioBtn, options = {}) {
      const { skipSave = false, autoSelect = false } = options;
      if (!currentPreset) {
        return false;
      }
      const isActive = scenarioBtn.classList.contains('active');

      if (isActive && !autoSelect) {
        if (presetEditMode && !skipSave) {
          const saved = await persistScenarioChangesOrWarn('deselect-scenario');
          if (!saved) {
            return false;
          }
        }

        scenarioBtn.classList.remove('active');
        currentScenario = null;
        scenarioEditingActive = false;
        tempScenarioSelections = [];
        clearPresetVisualization();
        clearScenarioFactorDisplay();
        if (presetEditMode) {
          deactivateScenarioEditingUI();
        }
        resetScenarioDirtyFlags();
        updateCollapsedPanelTitle('Scenarios');
        return true;
      }

      if (presetEditMode && currentScenario && currentScenario !== scenarioKey && !skipSave) {
        const saved = await persistScenarioChangesOrWarn('switch-scenario');
        if (!saved) {
          return false;
        }
      }

      document.querySelectorAll('.scenario-btn').forEach(b => b.classList.remove('active'));
      scenarioBtn.classList.add('active');
      currentScenario = scenarioKey;

      ensureScenarioFactorState(currentPreset, scenarioKey);
      updateScenarioFactorSliders(currentPreset, scenarioKey);

      if (presetEditMode) {
        activateScenarioEditingForCurrentScenario();
      } else {
        drawWorkflow(currentPreset, scenarioKey);
      }

      updateCollapsedPanelTitle('Scenarios');
      return true;
    }
    
    // Panel collapse functionality
    function togglePanel(panelId, btnId, panelName) {
      const content = document.getElementById(panelId);
      const btn = document.getElementById(btnId);
      const header = btn.closest('.panel-header');
      const titleSpan = header.querySelector('.panel-title');
      
      const isCollapsed = content.classList.contains('collapsed');
      
      if (isCollapsed) {
        // Expand
        content.classList.remove('collapsed');
        btn.textContent = '−';
        titleSpan.textContent = panelName;
      } else {
        // Collapse
        content.classList.add('collapsed');
        btn.textContent = '+';
        
        // Update title with selected item
        const selectedItem = getSelectedItemName(panelName);
        titleSpan.textContent = `${panelName}: ${selectedItem}`;
      }
    }
    
    function getSelectedItemName(panelName) {
      if (panelName === 'Profile Presets') {
        const activePresetBtn = document.querySelector('.preset-btn.active');
        return activePresetBtn ? activePresetBtn.textContent : 'None';
      } else if (panelName === 'Scenarios') {
        const activeScenarioBtn = document.querySelector('.scenario-btn.active');
        return activeScenarioBtn ? activeScenarioBtn.textContent : 'None';
      } else if (panelName === 'Product Capabilities') {
        const activeProductBtn = document.querySelector('.product-btn.active');
        return activeProductBtn ? activeProductBtn.textContent : 'None';
      }
      return 'None';
    }
    
    function updateCollapsedPanelTitle(panelName) {
      let headerId, contentId;
      
      if (panelName === 'Profile Presets') {
        headerId = 'presetPanelHeader';
        contentId = 'presetPanelContent';
      } else if (panelName === 'Scenarios') {
        headerId = 'scenarioPanelHeader';
        contentId = 'scenarioPanelContent';
      } else if (panelName === 'Product Capabilities') {
        headerId = 'productPanelHeader';
        contentId = 'productPanelContent';
      }
      
      const header = document.getElementById(headerId);
      const content = document.getElementById(contentId);
      const titleSpan = header.querySelector('.panel-title');
      
      // Only update if panel is collapsed
      if (content.classList.contains('collapsed')) {
        const selectedItem = getSelectedItemName(panelName);
        titleSpan.textContent = `${panelName}: ${selectedItem}`;
      }
    }
    
    // Add event listeners for collapse buttons
    document.getElementById('presetCollapseBtn').addEventListener('click', (e) => {
      e.stopPropagation();
      togglePanel('presetPanelContent', 'presetCollapseBtn', 'Profile Presets');
    });
    
    document.getElementById('scenarioCollapseBtn').addEventListener('click', (e) => {
      e.stopPropagation();
      togglePanel('scenarioPanelContent', 'scenarioCollapseBtn', 'Scenarios');
    });
    
    document.getElementById('productCollapseBtn').addEventListener('click', (e) => {
      e.stopPropagation();
      togglePanel('productPanelContent', 'productCollapseBtn', 'Product Capabilities');
    });
    
    // Allow clicking on header to toggle as well
    document.getElementById('presetPanelHeader').addEventListener('click', () => {
      togglePanel('presetPanelContent', 'presetCollapseBtn', 'Profile Presets');
    });
    
    document.getElementById('productPanelHeader').addEventListener('click', () => {
      togglePanel('productPanelContent', 'productCollapseBtn', 'Product Capabilities');
    });
    
    // UIs will be initialized after data loads in DOMContentLoaded handler
    // (removed immediate initialization to prevent race condition)

    // Preset button event handlers are now added dynamically in initializePresetUI

    // Preset edit mode
    let presetEditMode = false;
    let tempPresetSelections = [];
    let scenarioEditingActive = false;
    let tempScenarioSelections = [];
    let scenarioDirty = { factors: false, workflow: false };
    let productEditMode = false;
    let tempProductSelections = [];
    let productDirty = false;
    
    const presetEditToggle = document.getElementById('presetEditToggle');
    const exitPresetEditBtn = document.getElementById('exitPresetEditBtn');
    const renamePresetBtn = document.getElementById('renamePresetBtn');
    const deletePresetBtn = document.getElementById('deletePresetBtn');
    const presetEditInfo = document.getElementById('presetEditInfo');
    const scenarioEditControls = document.getElementById('scenarioEditControls');
    const renameScenarioBtn = document.getElementById('renameScenarioBtn');
    const deleteScenarioBtn = document.getElementById('deleteScenarioBtn');
    const scenarioEditInfo = document.getElementById('scenarioEditInfo');
    const productEditToggle = document.getElementById('editModeToggle');
    const exitProductEditBtn = document.getElementById('exitProductEditBtn');
    const renameProductBtn = document.getElementById('renameProductBtn');
    const deleteProductBtn = document.getElementById('deleteProductBtn');
    const productEditControls = document.getElementById('productEditControls');
    const productEditInfo = document.getElementById('editModeInfo');

    if (renameScenarioBtn) {
      renameScenarioBtn.style.display = 'none';
      renameScenarioBtn.disabled = true;
    }
    if (deleteScenarioBtn) {
      deleteScenarioBtn.style.display = 'none';
      deleteScenarioBtn.disabled = true;
    }
    if (renameProductBtn) {
      renameProductBtn.disabled = true;
    }
    if (deleteProductBtn) {
      deleteProductBtn.disabled = true;
    }
    
    // Pencil icon toggles edit mode
    presetEditToggle.addEventListener('click', async () => {
      if (!presetEditMode) {
        if (productEditMode) {
          const productExited = await exitProductEditMode();
          if (!productExited) {
            return;
          }
        }
        enterPresetEditMode();
      } else {
        await exitPresetEditMode();
      }
    });
    
    // Exit button in edit controls
    exitPresetEditBtn.addEventListener('click', async () => {
      await exitPresetEditMode();
    });
    
    // Rename button - operates on currently selected preset
    renamePresetBtn.addEventListener('click', async () => {
      if (!currentPreset) {
        alert('Please select a preset first.');
        return;
      }
      
      const currentName = presetMetadata[currentPreset];
      const newName = prompt(`Enter a new name for "${currentName}":`, currentName);
      
      if (!newName || newName.trim() === '' || newName === currentName) {
        return;
      }
      
      try {
        // Update the metadata with the new display name
        presetMetadata[currentPreset] = newName.trim();
        
        // Update in API
        const profileData = DataTransform.frontendProfileToDb(currentPreset, presetFactors, presetMetadata);
        await API.updateProfile(currentPreset, profileData);
        
        // Reinitialize UI to show the new name
        initializePresetUI();
        
        // Reselect the renamed preset
        const presetBtn = document.querySelector(`[data-preset="${currentPreset}"]`);
        if (presetBtn) {
          presetBtn.classList.add('active');
        }
        
        // Re-add the "+" button if we're in edit mode (after UI updates)
        if (presetEditMode) {
          requestAnimationFrame(() => {
            const existingAddBtn = document.getElementById('addPresetBtn');
            if (!existingAddBtn) {
              const presetButtonsContainer = document.querySelector('.preset-buttons');
              const addBtn = document.createElement('button');
              addBtn.className = 'add-btn';
              addBtn.id = 'addPresetBtn';
              addBtn.textContent = '+';
              addBtn.title = 'Create a new profile preset';
              addBtn.addEventListener('click', handleAddPreset);
              // Insert at the beginning instead of appending
              presetButtonsContainer.insertBefore(addBtn, presetButtonsContainer.firstChild);
            }
          });
        }
        
      } catch (error) {
        console.error('Failed to rename preset:', error);
        alert('Failed to rename preset. Please try again.');
      }
    });
    
    // Delete button - operates on currently selected preset
    deletePresetBtn.addEventListener('click', async () => {
      if (!currentPreset) {
        alert('Please select a preset first.');
        return;
      }
      
      const presetName = presetMetadata[currentPreset];
      const scenarioCount = Object.keys(scenarioMetadata[currentPreset] || {}).length;
      
      const message = `Are you sure you want to delete "${presetName}"?\n\n` +
                      `This will permanently delete:\n` +
                      `- The profile preset\n` +
                      `- ${scenarioCount} scenario(s)\n` +
                      `- All associated workflow paths\n\n` +
                      `This action cannot be undone.`;
      
      if (confirm(message)) {
        try {
          // Delete from API (cascades to scenarios and workflows)
          await API.deleteProfile(currentPreset);
          
          // Remove from local data structures
          delete presets[currentPreset];
          delete presetFactors[currentPreset];
          delete presetMetadata[currentPreset];
          delete scenarioMetadata[currentPreset];
          
          // Remove all scenario factors for this preset (composite keys)
          Object.keys(scenarioFactors).forEach(factorKey => {
            if (factorKey.startsWith(`${currentPreset}:`)) {
              delete scenarioFactors[factorKey];
            }
          });
          
          // Remove all workflows for this preset
          Object.keys(workflows).forEach(workflowKey => {
            if (workflowKey.startsWith(`${currentPreset}:`)) {
              delete workflows[workflowKey];
            }
          });
          
          // Clear current selection
          currentPreset = null;
          currentScenario = null;
          
          // Reinitialize UI - this will auto-select first preset
          initializePresetUI(true);
          
          // Load scenarios for the newly selected preset
          if (currentPreset) {
            initializeScenarioUI(true);
            updateFactorSliders(currentPreset);
          } else {
            // No presets left - clear scenario UI
            initializeScenarioUI();
            clearFactorSliders();
          }
          
          // Re-add the "+" button if we're in edit mode (after UI updates)
          if (presetEditMode) {
            requestAnimationFrame(() => {
              const existingAddBtn = document.getElementById('addPresetBtn');
              if (!existingAddBtn) {
                const presetButtonsContainer = document.querySelector('.preset-buttons');
                const addBtn = document.createElement('button');
                addBtn.className = 'add-btn';
                addBtn.id = 'addPresetBtn';
                addBtn.textContent = '+';
                addBtn.title = 'Create a new profile preset';
                addBtn.addEventListener('click', handleAddPreset);
                // Insert at the beginning instead of appending
                presetButtonsContainer.insertBefore(addBtn, presetButtonsContainer.firstChild);
              }
            });
          }
          
        } catch (error) {
          console.error('Failed to delete preset:', error);
          alert('Failed to delete preset. Please try again.');
        }
      }
    });
    
    // Handler for Add Preset button (added dynamically in enterPresetEditMode)
    async function handleAddPreset() {
      const presetName = prompt('Enter a name for the new preset:');
      if (!presetName || presetName.trim() === '') {
        return;
      }
      
      // Create a key from the preset name (lowercase, replace spaces with dashes)
      const presetKey = presetName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
      
      // Check if preset already exists by key
      if (presets[presetKey]) {
        alert('A preset with this name already exists. Please choose a different name.');
        return;
      }
      
      // Check if preset name already exists in metadata (case-insensitive)
      const normalizedNewName = presetName.trim().toLowerCase();
      const existingNames = Object.values(presetMetadata).map(name => name.toLowerCase());
      if (existingNames.includes(normalizedNewName)) {
        alert('A preset with this name already exists. Please choose a different name.');
        return;
      }
      
      try {
        // Create new preset with default factors
        const newPresetFactors = {
          expertise: 50,
          aicapability: 50,
          governance: 50
        };
        
        // Update local data structures FIRST (so transform function can access them)
        presets[presetKey] = [];
        presetFactors[presetKey] = newPresetFactors;
        presetMetadata[presetKey] = presetName;
        
        const profileData = DataTransform.frontendProfileToDb(presetKey, presetFactors, presetMetadata);
        
        await API.createProfile(profileData);
        
        // Initialize empty scenario metadata for this preset
        if (!scenarioMetadata[presetKey]) {
          scenarioMetadata[presetKey] = {};
        }
        
        // Reinitialize UI to show new preset
        initializePresetUI();
        
        // Select the new preset manually
        currentPreset = presetKey;
        
        // Update the UI to show it as selected
        const newPresetBtn = document.querySelector(`[data-preset="${presetKey}"]`);
        if (newPresetBtn) {
          newPresetBtn.classList.add('active');
        }
        
        // Re-add the "+" button if we're in edit mode (after UI reinitialize clears it)
        if (presetEditMode) {
          requestAnimationFrame(() => {
            const existingAddBtn = document.getElementById('addPresetBtn');
            if (!existingAddBtn) {
              const presetButtonsContainer = document.getElementById('presetButtonsContainer');
              const addBtn = document.createElement('button');
              addBtn.className = 'add-btn';
              addBtn.id = 'addPresetBtn';
              addBtn.textContent = '+';
              addBtn.title = 'Create a new profile preset';
              addBtn.addEventListener('click', handleAddPreset);
              // Insert at the beginning instead of appending
              presetButtonsContainer.insertBefore(addBtn, presetButtonsContainer.firstChild);
            }
          });
        }
        
        // Load scenarios for the new preset
        try {
          initializeScenarioUI(true);
        } catch (scenarioError) {
          console.warn('Could not initialize scenarios immediately:', scenarioError);
        }
        
        // Update factor sliders
        updateFactorSliders(presetKey);
        
        console.log(`Preset "${presetName}" created successfully`);
      } catch (error) {
        console.error('Failed to create preset:', error);
        console.error('Error details:', error.message, error.stack);
        alert('Failed to create preset. Please try again.');
      }
    }

    // ============================================================================
    // SCENARIO ADD HANDLER (Simplified for Phase 1)
    // ============================================================================
    async function handleAddScenario() {
      // Check if any profiles exist
      if (Object.keys(presets).length === 0) {
        alert('You have not yet created a profile. Create at least one profile before you add any scenarios to that profile.');
        return;
      }
      
      if (!currentPreset) {
        alert('Please select a Profile Preset first before adding a scenario.');
        return;
      }

      if (presetEditMode && currentScenario) {
        const saved = await persistScenarioChangesOrWarn('add-scenario');
        if (!saved) {
          return;
        }
      }
      
      const scenarioName = prompt('Enter a name for the new scenario:');
      if (!scenarioName || scenarioName.trim() === '') {
        return;
      }
      
      const scenarioKey = scenarioName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
      
      // Check if scenario already exists for this preset (by key)
      const presetScenarios = scenarioMetadata[currentPreset] || {};
      if (presetScenarios[scenarioKey]) {
        alert('A scenario with this name already exists for this preset. Please choose a different name.');
        return;
      }
      
      // Check if scenario name already exists for this preset (case-insensitive)
      const normalizedNewName = scenarioName.trim().toLowerCase();
      const existingScenarioNames = Object.values(presetScenarios).map(name => name.toLowerCase());
      if (existingScenarioNames.includes(normalizedNewName)) {
        alert('A scenario with this name already exists for this preset. Please choose a different name.');
        return;
      }
      
      try {
        // Create default scenario factors
        const defaultScenarioFactors = {
          importance: 50,
          complexity: 50,
          maturity: 50
        };
        
        // Add to local data structures first (needed for transformation)
        if (!scenarioMetadata[currentPreset]) {
          scenarioMetadata[currentPreset] = {};
        }
        scenarioMetadata[currentPreset][scenarioKey] = scenarioName;
        
        const compositeKey = `${currentPreset}:${scenarioKey}`;
        scenarioFactors[compositeKey] = defaultScenarioFactors;
        
        // Transform to database format
        const scenarioData = DataTransform.frontendScenarioToDb(currentPreset, scenarioKey, scenarioFactors, scenarioMetadata);
        
        // Create in database
        await API.createScenario(currentPreset, scenarioData);
        
        // Refresh scenario UI
        initializeScenarioUI();
        
        // Auto-select the new scenario
        const newScenarioBtn = document.querySelector(`[data-scenario="${scenarioKey}"]`);
        if (newScenarioBtn) {
          await handleScenarioSelection(scenarioKey, newScenarioBtn, { skipSave: true });
        }
        
        console.log(`Scenario "${scenarioName}" created successfully for preset "${currentPreset}"`);
      } catch (error) {
        console.error('Failed to create scenario:', error);
        console.error('Error details:', error.message, error.stack);
        alert('Failed to create scenario. Please try again.');
      }
    }
    
    // Attach event listener to the scenario "+" button
    document.getElementById('addScenarioBtn').addEventListener('click', handleAddScenario);

    if (renameScenarioBtn) {
      renameScenarioBtn.addEventListener('click', async () => {
        if (!presetEditMode || !currentPreset || !currentScenario) {
          alert('Select a scenario while editing a profile preset to rename it.');
          return;
        }

        const currentName = scenarioMetadata[currentPreset]?.[currentScenario] || currentScenario;
        const newName = prompt(`Enter a new name for "${currentName}":`, currentName);

        if (!newName || newName.trim() === '' || newName.trim() === currentName) {
          return;
        }

        const normalizedNewName = newName.trim().toLowerCase();
        const presetScenarios = scenarioMetadata[currentPreset] || {};
        const nameConflict = Object.entries(presetScenarios).some(([scenarioKey, displayName]) => {
          if (scenarioKey === currentScenario) {
            return false;
          }
          return (displayName || '').toLowerCase() === normalizedNewName;
        });

        if (nameConflict) {
          alert('A scenario with this name already exists for this preset. Please choose a different name.');
          return;
        }

        const saved = await persistScenarioChangesOrWarn('rename-scenario');
        if (!saved) {
          return;
        }

        const originalName = currentName;
        scenarioMetadata[currentPreset][currentScenario] = newName.trim();

        try {
          const scenarioData = DataTransform.frontendScenarioToDb(currentPreset, currentScenario, scenarioFactors, scenarioMetadata);
          await API.updateScenario(currentPreset, currentScenario, scenarioData);

          initializeScenarioUI();
          const scenarioBtn = document.querySelector(`.scenario-btn[data-scenario="${currentScenario}"]`);
          if (scenarioBtn) {
            await handleScenarioSelection(currentScenario, scenarioBtn, { skipSave: true, autoSelect: true });
          }
          updateCollapsedPanelTitle('Scenarios');
        } catch (error) {
          console.error('Failed to rename scenario:', error);
          scenarioMetadata[currentPreset][currentScenario] = originalName;
          alert('Failed to rename scenario. Please try again.');
        }
      });
    }

    if (deleteScenarioBtn) {
      deleteScenarioBtn.addEventListener('click', async () => {
        if (!presetEditMode || !currentPreset || !currentScenario) {
          alert('Select a scenario while editing a profile preset to delete it.');
          return;
        }

        const scenarioName = scenarioMetadata[currentPreset]?.[currentScenario] || currentScenario;
        const confirmation = confirm(`Are you sure you want to permanently delete "${scenarioName}" from preset "${presetMetadata[currentPreset]}"? This will remove any associated workflow steps.`);
        if (!confirmation) {
          return;
        }

        const compositeKey = `${currentPreset}:${currentScenario}`;

        try {
          await API.deleteScenario(currentPreset, currentScenario);

          delete scenarioMetadata[currentPreset][currentScenario];
          delete scenarioFactors[compositeKey];
          delete workflows[compositeKey];

          currentScenario = null;
          tempScenarioSelections = [];
          clearPresetVisualization();
          clearScenarioFactorDisplay();
          deactivateScenarioEditingUI();
          resetScenarioDirtyFlags();

          initializeScenarioUI(true);
          updateCollapsedPanelTitle('Scenarios');
        } catch (error) {
          console.error('Failed to delete scenario:', error);
          alert('Failed to delete scenario. Please try again.');
        }
      });
    }

    // ============================================================================
    // SCENARIO EDIT MODE - PHASE 2 (Currently disabled, will be refactored)
    // ============================================================================
    /*
    // Scenario edit mode
    let scenarioEditMode = false;
    let tempScenarioSelections = [];
    
    const scenarioEditToggle = document.getElementById('scenarioEditToggle');
    const editScenarioSelect = document.getElementById('editScenarioSelect');
    const addScenarioBtn = document.getElementById('addScenarioBtn');
    const deleteScenarioBtn = document.getElementById('deleteScenarioBtn');
    const renameScenarioBtn = document.getElementById('renameScenarioBtn');
    const scenarioEditInfo = document.getElementById('scenarioEditInfo');
    
    scenarioEditToggle.addEventListener('click', async () => {
      if (!scenarioEditMode) {
        enterScenarioEditMode();
      } else {
        // Save on exit
        await exitScenarioEditMode();
      }
    });
    
    editScenarioSelect.addEventListener('change', () => {
      if (scenarioEditMode) {
        loadExistingScenarioSelections();
        
        // Load scenario factors when switching scenarios in edit mode
        const selectedScenario = editScenarioSelect.value;
        if (selectedScenario && currentPreset) {
          updateScenarioFactorSliders(currentPreset, selectedScenario);
        }
      }
    });
    
    deleteScenarioBtn.addEventListener('click', async () => {
      if (!currentPreset) {
        alert('Please select a Profile Preset first.');
        return;
      }
      
      const selectedScenario = editScenarioSelect.value;
      const scenarioName = editScenarioSelect.options[editScenarioSelect.selectedIndex].text;
      
      // Check if this is the last scenario for the preset
      const presetScenarios = scenarioMetadata[currentPreset] || {};
      const scenarioCount = Object.keys(presetScenarios).length;
      
      if (scenarioCount <= 1) {
        alert('Cannot delete the last scenario. Every preset must have at least one scenario.');
        return;
      }
      
      if (selectedScenario && confirm(`Are you sure you want to permanently delete "${scenarioName}" from preset "${presetMetadata[currentPreset]}"?`)) {
        try {
          // Delete from API (cascades to workflow steps)
          await API.deleteScenario(currentPreset, selectedScenario);
          
          // Remove from local data structures
          delete scenarioMetadata[currentPreset][selectedScenario];
          
          const compositeKey = `${currentPreset}:${selectedScenario}`;
          delete scenarioFactors[compositeKey];
          delete workflows[compositeKey];
          
          initializeScenarioUI();
          
          clearPresetEditSelections();
          tempScenarioSelections = [];
          
          if (editScenarioSelect.options.length > 0) {
            editScenarioSelect.selectedIndex = 0;
            loadExistingScenarioSelections();
            // Load factors for the newly selected scenario
            const newSelectedScenario = editScenarioSelect.value;
            if (newSelectedScenario && currentPreset) {
              updateScenarioFactorSliders(currentPreset, newSelectedScenario);
            }
          } else {
            await exitScenarioEditMode();
          }
          
        } catch (error) {
          console.error('Failed to delete scenario:', error);
          alert('Failed to delete scenario. Please try again.');
        }
      }
    });
    
    renameScenarioBtn.addEventListener('click', async () => {
      if (!currentPreset) {
        alert('Please select a Profile Preset first.');
        return;
      }
      
      const selectedScenario = editScenarioSelect.value;
      const currentName = editScenarioSelect.options[editScenarioSelect.selectedIndex].text;
      
      if (selectedScenario) {
        const newName = prompt(`Enter a new name for "${currentName}":`, currentName);
        if (!newName || newName.trim() === '' || newName === currentName) {
          return;
        }
        
        try {
          // Update scenario name in current preset's scenario list
          scenarioMetadata[currentPreset][selectedScenario] = newName.trim();
          
          // Update in API
          const compositeKey = `${currentPreset}:${selectedScenario}`;
          const scenarioData = DataTransform.frontendScenarioToDb(currentPreset, selectedScenario, scenarioFactors[compositeKey]);
          scenarioData.name = newName.trim();
          await API.updateScenario(currentPreset, selectedScenario, scenarioData);
          
          initializeScenarioUI();
          
          if (scenarioEditMode) {
            editScenarioSelect.value = selectedScenario;
            loadExistingScenarioSelections();
          }
          
        } catch (error) {
          console.error('Failed to rename scenario:', error);
          alert('Failed to rename scenario. Please try again.');
        }
      }
    });
    
    addScenarioBtn.addEventListener('click', async () => {
      if (!currentPreset) {
        alert('Please select a Profile Preset first before adding a scenario.');
        return;
      }
      
      const scenarioName = prompt('Enter a name for the new scenario:');
      if (!scenarioName || scenarioName.trim() === '') {
        return;
      }
      
      const scenarioKey = scenarioName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
      
      // Check if scenario already exists for this preset (by key)
      const presetScenarios = scenarioMetadata[currentPreset] || {};
      if (presetScenarios[scenarioKey]) {
        alert('A scenario with this name already exists for this preset. Please choose a different name.');
        return;
      }
      
      // Check if scenario name already exists for this preset (case-insensitive)
      const normalizedNewName = scenarioName.trim().toLowerCase();
      const existingScenarioNames = Object.values(presetScenarios).map(name => name.toLowerCase());
      if (existingScenarioNames.includes(normalizedNewName)) {
        alert('A scenario with this name already exists for this preset. Please choose a different name.');
        return;
      }
      
      try {
        // Create default scenario factors
        const defaultScenarioFactors = {
          importance: 50,
          complexity: 50,
          maturity: 50
        };
        
        const scenarioData = DataTransform.frontendScenarioToDb(currentPreset, scenarioKey, defaultScenarioFactors);
        scenarioData.name = scenarioName; // Use the display name
        
        await API.createScenario(currentPreset, scenarioData);
        
        // Add scenario to current preset only
        if (!scenarioMetadata[currentPreset]) {
          scenarioMetadata[currentPreset] = {};
        }
        scenarioMetadata[currentPreset][scenarioKey] = scenarioName;
        
        const compositeKey = `${currentPreset}:${scenarioKey}`;
        scenarioFactors[compositeKey] = defaultScenarioFactors;
        
        initializeScenarioUI();
        
        if (scenarioEditMode) {
          editScenarioSelect.value = scenarioKey;
          loadExistingScenarioSelections();
          // Load factors for the newly created scenario
          updateScenarioFactorSliders(currentPreset, scenarioKey);
        }
        
      } catch (error) {
        console.error('Failed to create scenario:', error);
        alert('Failed to create scenario. Please try again.');
      }
    });
    */
    // ============================================================================
    // End of commented out Scenario Edit Mode (Phase 2)
    // ============================================================================
    
    function enterPresetEditMode() {
      presetEditMode = true;
      
      // Show edit controls
      document.getElementById('presetEditControls').style.display = 'block';
      presetEditToggle.classList.add('active');
      
      // Show scenario "+" button
      document.getElementById('addScenarioBtn').style.display = 'inline-block';
      
      // Add "+" button to create new preset at the BEGINNING of the list
      const presetButtonsContainer = document.getElementById('presetButtonsContainer');
      const addBtn = document.createElement('button');
      addBtn.className = 'add-btn';
      addBtn.id = 'addPresetBtn';
      addBtn.textContent = '+';
      addBtn.title = 'Create a new profile preset';
      addBtn.addEventListener('click', handleAddPreset);
      // Insert at the beginning instead of appending
      presetButtonsContainer.insertBefore(addBtn, presetButtonsContainer.firstChild);
      
      // Enable workflow editing handlers
      addScenarioEditClickHandlers();

      // Reset scenario editing UI before enabling
      deactivateScenarioEditingUI();

      // Add factor slider click handlers
      addFactorSliderClickHandlers('preset');
      
      // If a preset is already selected, load its factors
      if (currentPreset) {
        updateFactorSliders(currentPreset);
      }
      
      if (currentScenario) {
        activateScenarioEditingForCurrentScenario();
      } else {
        clearScenarioFactorDisplay();
      }
      
      console.log('Entered preset edit mode');
    }
    
    async function exitPresetEditMode() {
      if (!presetEditMode) {
        return true;
      }

      const scenarioSaved = await persistScenarioChangesOrWarn('exit-edit-mode');
      if (!scenarioSaved) {
        return false;
      }
      
      // Auto-save current preset if one is selected
      if (currentPreset && presetFactors[currentPreset]) {
        try {
          const profileData = DataTransform.frontendProfileToDb(currentPreset, presetFactors, presetMetadata);
          await API.updateProfile(currentPreset, profileData);
          console.log(`Preset ${currentPreset} auto-saved on exit`);
        } catch (error) {
          console.error('Failed to save profile:', error);
          alert('Failed to save profile changes. Please try again.');
          return false; // Don't exit edit mode if save failed
        }
      }
      
      presetEditMode = false;
      
      // Hide edit controls
      document.getElementById('presetEditControls').style.display = 'none';
      presetEditToggle.classList.remove('active');
      
      // Hide scenario "+" button
      document.getElementById('addScenarioBtn').style.display = 'none';
      
      // Remove "+" button
      const addBtn = document.getElementById('addPresetBtn');
      if (addBtn) addBtn.remove();
      
      // Disable scenario editing UI and handlers
    removeScenarioEditClickHandlers();
    deactivateScenarioEditingUI();
    resetScenarioDirtyFlags();
      tempScenarioSelections = [];
      
      // Remove factor slider click handlers
      removeFactorSliderClickHandlers('preset');

      if (currentPreset && currentScenario) {
        drawWorkflow(currentPreset, currentScenario);
      }
      
      console.log('Exited preset edit mode');
      return true;
    }
    
    function addFactorSliderClickHandlers(context) {
      let factorNames, idPrefix, dataStructure;
      
      if (context === 'preset') {
        factorNames = ['expertise', 'aicapability', 'governance'];
        idPrefix = 'bar-';
        dataStructure = presetFactors;
      } else if (context === 'scenario') {
        factorNames = ['importance', 'complexity', 'maturity'];
        idPrefix = 'bar-scenario-';
        dataStructure = scenarioFactors;
      }
      
      factorNames.forEach(name => {
        const barElement = document.getElementById(`${idPrefix}${name}`);
        if (!barElement) return;
        const barContainer = barElement.parentElement;
        if (!barContainer) return;
        
        barContainer.style.cursor = 'pointer';
        if (barContainer._factorClickHandler) {
          barContainer.removeEventListener('click', barContainer._factorClickHandler);
        }
        const clickHandler = function(event) {
          handleFactorSliderClick(event, context, dataStructure, name);
        };
        barContainer._factorClickHandler = clickHandler;
        barContainer.addEventListener('click', clickHandler);
        barContainer.dataset.factor = name;
        barContainer.dataset.context = context;

        const inputId = context === 'preset' ? `input-${name}` : `input-scenario-${name}`;
        const input = document.getElementById(inputId);
        if (input) {
          input.disabled = false;
          input.style.display = 'inline-block';
          if (input._factorInputHandler) {
            input.removeEventListener('input', input._factorInputHandler);
            input.removeEventListener('change', input._factorInputHandler);
          }
          const inputHandler = function(event) {
            handleFactorInputChange(event, context, dataStructure, name);
          };
          input._factorInputHandler = inputHandler;
          input.addEventListener('input', inputHandler);
          input.addEventListener('change', inputHandler);
        }
      });
    }
    
    function removeFactorSliderClickHandlers(context) {
      let factorNames, idPrefix;
      
      if (context === 'preset') {
        factorNames = ['expertise', 'aicapability', 'governance'];
        idPrefix = 'bar-';
      } else if (context === 'scenario') {
        factorNames = ['importance', 'complexity', 'maturity'];
        idPrefix = 'bar-scenario-';
      }
      
      factorNames.forEach(name => {
        const barElement = document.getElementById(`${idPrefix}${name}`);
        if (!barElement) return;
        const barContainer = barElement.parentElement;
        if (!barContainer) return;

        barContainer.style.cursor = 'default';
        if (barContainer._factorClickHandler) {
          barContainer.removeEventListener('click', barContainer._factorClickHandler);
          delete barContainer._factorClickHandler;
        }
        delete barContainer.dataset.factor;
        delete barContainer.dataset.context;

        const inputId = context === 'preset' ? `input-${name}` : `input-scenario-${name}`;
        const input = document.getElementById(inputId);
        if (input) {
          input.disabled = true;
          input.style.display = 'none';
          if (input._factorInputHandler) {
            input.removeEventListener('input', input._factorInputHandler);
            input.removeEventListener('change', input._factorInputHandler);
            delete input._factorInputHandler;
          }
        }
      });
    }
    
    function handleFactorSliderClick(event, context, dataStructure, factorName) {
      // Get the selected key based on context
      let selectedKey, lookupKey;
      
      if (context === 'preset') {
        selectedKey = currentPreset;
        lookupKey = selectedKey;
      } else if (context === 'scenario') {
        selectedKey = currentScenario;
        if (!currentPreset || !selectedKey) return;
        lookupKey = `${currentPreset}:${selectedKey}`;
      }
      
      if (!selectedKey) return;
      
      // Ensure the key exists in the data structure
      if (!dataStructure[lookupKey]) {
        // Initialize if doesn't exist (for scenarios, create default values)
        if (context === 'scenario') {
          dataStructure[lookupKey] = {
            importance: 50,
            complexity: 50,
            maturity: 50
          };
        } else {
          return;
        }
      }
      
      const barContainer = event.currentTarget;
      const rect = barContainer.getBoundingClientRect();
      
      // Calculate percentage based on click position (inverted because bars fill from bottom)
      const clickY = event.clientY - rect.top;
      const containerHeight = rect.height;
      const percentage = Math.max(0, Math.min(100, Math.round((1 - clickY / containerHeight) * 100)));
      
      // Update the factor value
      dataStructure[lookupKey][factorName] = percentage;
      if (context === 'scenario') {
        scenarioDirty.factors = true;
      }
      
      // Update the visual display
      const idPrefix = context === 'preset' ? 'bar-' : 'bar-scenario-';
      updateSingleFactorSlider(`${idPrefix}${factorName}`, percentage);
    }
    
    function handleFactorInputChange(event, context, dataStructure, factorName) {
      // Get the selected key based on context
      let selectedKey, lookupKey;
      
      if (context === 'preset') {
        selectedKey = currentPreset;
        lookupKey = selectedKey;
      } else if (context === 'scenario') {
        selectedKey = currentScenario;
        if (!currentPreset || !selectedKey) return;
        lookupKey = `${currentPreset}:${selectedKey}`;
      }
      
      if (!selectedKey) return;

      if (!dataStructure[lookupKey]) {
        if (context === 'scenario') {
          dataStructure[lookupKey] = {
            importance: 50,
            complexity: 50,
            maturity: 50
          };
        } else {
          return;
        }
      }

      let rawValue = event.target.value;
      
      // Allow empty value (treat as 0)
      if (rawValue === '') {
        dataStructure[lookupKey][factorName] = 0;
        const idPrefix = context === 'preset' ? 'bar-' : 'bar-scenario-';
        updateSingleFactorSlider(`${idPrefix}${factorName}`, 0);
        return;
      }

      let value = parseInt(rawValue, 10);
      if (Number.isNaN(value)) {
        return;
      }

      value = Math.max(0, Math.min(100, value));
      if (value.toString() !== rawValue.trim()) {
        event.target.value = value;
      }

      dataStructure[lookupKey][factorName] = value;
      if (context === 'scenario') {
        scenarioDirty.factors = true;
      }

      const idPrefix = context === 'preset' ? 'bar-' : 'bar-scenario-';
      updateSingleFactorSlider(`${idPrefix}${factorName}`, value);
    }
    
    function updateSingleFactorSlider(barId, value) {
      const bar = document.getElementById(barId);
      const valueDisplayId = barId.replace('bar-', 'value-');
      const valueDisplay = document.getElementById(valueDisplayId);
      const inputId = valueDisplayId.replace('value-', 'input-');
      const input = document.getElementById(inputId);
      
      if (bar && valueDisplay) {
        bar.style.height = value + '%';
        valueDisplay.textContent = value;
        if (input) {
          input.value = value;
        }
      }
    }

    // Scenario editing helpers
    function resetScenarioDirtyFlags() {
      scenarioDirty = { factors: false, workflow: false };
    }

    function ensureScenarioFactorState(presetKey, scenarioKey) {
      const compositeKey = `${presetKey}:${scenarioKey}`;
      if (!scenarioFactors[compositeKey]) {
        scenarioFactors[compositeKey] = {
          importance: 50,
          complexity: 50,
          maturity: 50
        };
      }
      return scenarioFactors[compositeKey];
    }

    function mapCellsToWorkflowPairs(cells) {
      return cells.map(cell => {
        const role = table.rows[cell.parentNode.rowIndex].cells[0].textContent;
        const focus = table.rows[0].cells[cell.cellIndex].textContent;
        return [role, focus];
      });
    }

    function clearScenarioFactorDisplay() {
      const factorNames = ['importance', 'complexity', 'maturity'];
      factorNames.forEach(name => {
        const bar = document.getElementById(`bar-scenario-${name}`);
        const valueDisplay = document.getElementById(`value-scenario-${name}`);
        const input = document.getElementById(`input-scenario-${name}`);
        if (bar) {
          bar.style.height = '0%';
        }
        if (valueDisplay) {
          valueDisplay.textContent = '-';
        }
        if (input) {
          input.value = '';
        }
      });
    }

    function activateScenarioEditingForCurrentScenario() {
      if (!presetEditMode || !currentPreset || !currentScenario) {
        return;
      }

      scenarioEditingActive = true;
      if (scenarioEditControls) {
        scenarioEditControls.style.display = 'block';
      }
      if (scenarioEditInfo) {
        scenarioEditInfo.style.display = 'block';
      }
      if (renameScenarioBtn) {
        renameScenarioBtn.style.display = 'inline-block';
        renameScenarioBtn.disabled = false;
      }
      if (deleteScenarioBtn) {
        deleteScenarioBtn.style.display = 'inline-block';
        deleteScenarioBtn.disabled = false;
      }

      ensureScenarioFactorState(currentPreset, currentScenario);
      addFactorSliderClickHandlers('scenario');
      loadExistingScenarioSelections(currentScenario);
      updateScenarioFactorSliders(currentPreset, currentScenario);
    }

    function deactivateScenarioEditingUI() {
      scenarioEditingActive = false;
      tempScenarioSelections = [];
      clearPresetEditSelections();
      removeFactorSliderClickHandlers('scenario');
      resetScenarioDirtyFlags();
      if (scenarioEditControls) {
        scenarioEditControls.style.display = 'none';
      }
      if (scenarioEditInfo) {
        scenarioEditInfo.style.display = 'none';
      }
      if (renameScenarioBtn) {
        renameScenarioBtn.style.display = 'none';
        renameScenarioBtn.disabled = true;
      }
      if (deleteScenarioBtn) {
        deleteScenarioBtn.style.display = 'none';
        deleteScenarioBtn.disabled = true;
      }
    }

    async function saveActiveScenarioChanges(reason = 'manual') {
      if (!presetEditMode || !currentPreset || !currentScenario) {
        resetScenarioDirtyFlags();
        return;
      }

      const compositeKey = `${currentPreset}:${currentScenario}`;
      const workflowData = mapCellsToWorkflowPairs(tempScenarioSelections);
      workflows[compositeKey] = workflowData;

      const updates = [];

      if (scenarioDirty.workflow) {
        const workflowSteps = DataTransform.frontendWorkflowToDb(currentPreset, currentScenario, workflowData);
        updates.push(API.saveWorkflowSteps(currentPreset, currentScenario, workflowSteps));
      }

      if (scenarioDirty.factors) {
        ensureScenarioFactorState(currentPreset, currentScenario);
        const scenarioData = DataTransform.frontendScenarioToDb(currentPreset, currentScenario, scenarioFactors, scenarioMetadata);
        updates.push(API.updateScenario(currentPreset, currentScenario, scenarioData));
      }

      if (updates.length > 0) {
        await Promise.all(updates);
      }

      resetScenarioDirtyFlags();
    }

    async function persistScenarioChangesOrWarn(reason = 'manual') {
      try {
        await saveActiveScenarioChanges(reason);
        return true;
      } catch (error) {
        console.error(`Failed to save scenario changes (${reason}):`, error);
        alert('Failed to save scenario changes. Please resolve the issue before continuing.');
        return false;
      }
    }

    function addScenarioEditClickHandlers() {
      for (let row of table.rows) {
        for (let cell of row.cells) {
          if (cell.cellIndex === 0 || row.rowIndex === 0) continue;
          if (cell._scenarioEditHandlerAttached) continue;
          cell.addEventListener('click', handleScenarioEditCellClick);
          cell._scenarioEditHandlerAttached = true;
        }
      }
    }

    function removeScenarioEditClickHandlers() {
      for (let row of table.rows) {
        for (let cell of row.cells) {
          if (cell.cellIndex === 0 || row.rowIndex === 0) continue;
          if (!cell._scenarioEditHandlerAttached) continue;
          cell.removeEventListener('click', handleScenarioEditCellClick);
          delete cell._scenarioEditHandlerAttached;
        }
      }
    }

    function handleScenarioEditCellClick(event) {
      if (!presetEditMode || !scenarioEditingActive || !currentScenario || productEditMode) {
        return;
      }

      const cell = event.currentTarget;
      const index = tempScenarioSelections.indexOf(cell);

      if (index > -1) {
        tempScenarioSelections.splice(index);
      } else {
        tempScenarioSelections.push(cell);
      }

      scenarioDirty.workflow = true;
      visualizeScenarioEdit();

      const workflowKey = `${currentPreset}:${currentScenario}`;
      workflows[workflowKey] = mapCellsToWorkflowPairs(tempScenarioSelections);
    }

    function loadExistingScenarioSelections(targetScenario = currentScenario) {
      tempScenarioSelections = [];
      clearPresetEditSelections();

      if (!currentPreset || !targetScenario) {
        resetScenarioDirtyFlags();
        return;
      }

      clearPresetVisualization();

      const workflowKey = `${currentPreset}:${targetScenario}`;
      const workflow = workflows[workflowKey] || [];

      workflow.forEach(([role, focus]) => {
        const cell = findCell(role, focus);
        if (cell) {
          tempScenarioSelections.push(cell);
        }
      });

      if (tempScenarioSelections.length > 0) {
        visualizeScenarioEdit();
      }

      resetScenarioDirtyFlags();
    }

    function visualizeScenarioEdit() {
      clearPresetEditSelections();

      tempScenarioSelections.forEach((cell, index) => {
        cell.classList.add('preset-selected');

        const dot = document.createElement('div');
        dot.className = 'preset-dot';
        dot.textContent = index + 1;

        const cellRect = cell.getBoundingClientRect();
        const tableRect = table.getBoundingClientRect();

        const x = cellRect.left - tableRect.left + cellRect.width / 2;
        const y = cellRect.top - tableRect.top + cellRect.height / 2;

        dot.style.left = (x - 10) + 'px';
        dot.style.top = (y - 10) + 'px';

        table.parentElement.appendChild(dot);
      });

      if (tempScenarioSelections.length > 1) {
        resizeCanvas();
        presetCtx.clearRect(0, 0, presetCanvas.width, presetCanvas.height);
        presetCtx.strokeStyle = '#9b59b6';
        presetCtx.lineWidth = 3;
        presetCtx.setLineDash([5, 5]);
        presetCtx.lineCap = 'round';
        presetCtx.lineJoin = 'round';

        const points = tempScenarioSelections.map(cell => {
          const cellRect = cell.getBoundingClientRect();
          const tableRect = table.getBoundingClientRect();
          return {
            x: cellRect.left - tableRect.left + cellRect.width / 2,
            y: cellRect.top - tableRect.top + cellRect.height / 2
          };
        });

        for (let i = 0; i < points.length - 1; i++) {
          const p1 = points[i];
          const p2 = points[i + 1];

          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          const curvature = Math.min(distance * 0.3, 50);

          const perpX = -dy / distance;
          const perpY = dx / distance;

          const controlX = (p1.x + p2.x) / 2 + perpX * curvature;
          const controlY = (p1.y + p2.y) / 2 + perpY * curvature;

          presetCtx.beginPath();
          presetCtx.moveTo(p1.x, p1.y);
          presetCtx.quadraticCurveTo(controlX, controlY, p2.x, p2.y);
          presetCtx.stroke();
        }
      }
    }
    
    function addPresetEditClickHandlers() {
      for (let row of table.rows) {
        for (let cell of row.cells) {
          if (cell.cellIndex === 0 || row.rowIndex === 0) continue;
          cell.addEventListener('click', handlePresetEditCellClick);
        }
      }
    }
    
    function removePresetEditClickHandlers() {
      for (let row of table.rows) {
        for (let cell of row.cells) {
          if (cell.cellIndex === 0 || row.rowIndex === 0) continue;
          cell.removeEventListener('click', handlePresetEditCellClick);
        }
      }
    }
    
    function handlePresetEditCellClick(event) {
      if (!presetEditMode) return;
      
      const cell = event.currentTarget;
      const index = tempPresetSelections.indexOf(cell);
      
      if (index > -1) {
        // Remove this cell and all subsequent cells
        tempPresetSelections.splice(index);
      } else {
        // Add to sequence
        tempPresetSelections.push(cell);
      }
      
      // Redraw
      visualizePresetEdit();
    }
    
    function loadExistingPresetSelections() {
      tempPresetSelections = [];
      clearPresetEditSelections();
      
      if (!currentPreset) return;
      
      const workflow = presets[currentPreset] || [];
      
      workflow.forEach(([role, focus]) => {
        const cell = findCell(role, focus);
        if (cell) {
          tempPresetSelections.push(cell);
        }
      });
      
      visualizePresetEdit();
    }
    
    function visualizePresetEdit() {
      clearPresetEditSelections();
      
      if (tempPresetSelections.length === 0) return;

      const points = [];
      
      tempPresetSelections.forEach((cell, index) => {
        cell.classList.add('preset-selected');
        
        // Create numbered dot
        const dot = document.createElement('div');
        dot.className = 'preset-dot';
        dot.textContent = index + 1;
        
        const cellRect = cell.getBoundingClientRect();
        const tableRect = table.getBoundingClientRect();
        
        const x = cellRect.left - tableRect.left + cellRect.width / 2;
        const y = cellRect.top - tableRect.top + cellRect.height / 2;
        
        dot.style.left = (x - 10) + 'px';
        dot.style.top = (y - 10) + 'px';
        
        table.parentElement.appendChild(dot);
        points.push({ x, y });
      });

      // Draw connecting lines
      if (points.length > 1) {
        resizeCanvas();
        presetCtx.clearRect(0, 0, presetCanvas.width, presetCanvas.height);
        presetCtx.strokeStyle = '#9b59b6';
        presetCtx.lineWidth = 3;
        presetCtx.setLineDash([5, 5]);
        presetCtx.lineCap = 'round';
        presetCtx.lineJoin = 'round';

        // Draw curved lines between points
        for (let i = 0; i < points.length - 1; i++) {
          const p1 = points[i];
          const p2 = points[i + 1];
          
          // Calculate control points for quadratic curve
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          // Create a curve that bends perpendicular to the line
          // The amount of curve is proportional to the distance
          const curvature = Math.min(distance * 0.3, 50);
          
          // Calculate perpendicular direction
          const perpX = -dy / distance;
          const perpY = dx / distance;
          
          // Control point is offset perpendicular to the line
          const controlX = (p1.x + p2.x) / 2 + perpX * curvature;
          const controlY = (p1.y + p2.y) / 2 + perpY * curvature;
          
          presetCtx.beginPath();
          presetCtx.moveTo(p1.x, p1.y);
          presetCtx.quadraticCurveTo(controlX, controlY, p2.x, p2.y);
          presetCtx.stroke();
        }
      }
    }
    
    function clearPresetEditSelections() {
      presetCtx.clearRect(0, 0, presetCanvas.width, presetCanvas.height);
      document.querySelectorAll('.preset-dot').forEach(dot => dot.remove());
      document.querySelectorAll('td.preset-selected').forEach(cell => cell.classList.remove('preset-selected'));
    }

    // ============================================================================
    // PRODUCT EDIT MODE
    // ============================================================================
    if (productEditToggle) {
      productEditToggle.addEventListener('click', async () => {
        if (!productEditMode) {
          if (presetEditMode) {
            const presetExited = await exitPresetEditMode();
            if (!presetExited) {
              return;
            }
          }
          await enterProductEditMode();
        } else {
          await exitProductEditMode();
        }
      });
    }

    if (exitProductEditBtn) {
      exitProductEditBtn.addEventListener('click', async () => {
        await exitProductEditMode();
      });
    }

    if (renameProductBtn) {
      renameProductBtn.addEventListener('click', async () => {
        if (!productEditMode || !currentProduct) {
          alert('Select a product while in Product Capabilities edit mode to rename it.');
          return;
        }

        const currentName = productMetadata[currentProduct] || currentProduct;
        const newName = prompt(`Enter a new name for "${currentName}":`, currentName);

        if (!newName || newName.trim() === '' || newName.trim() === currentName) {
          return;
        }

        const normalizedNewName = newName.trim().toLowerCase();
        const conflict = Object.entries(productMetadata).some(([productKey, displayName]) => {
          if (productKey === currentProduct) {
            return false;
          }
          return (displayName || '').toLowerCase() === normalizedNewName;
        });

        if (conflict) {
          alert('A product with this name already exists. Please choose a different name.');
          return;
        }

        const saved = await persistProductChangesOrWarn('rename-product');
        if (!saved) {
          return;
        }

        const originalName = currentName;
        productMetadata[currentProduct] = newName.trim();

        try {
          const capabilities = productCapabilities[currentProduct] || [];
          const productData = DataTransform.frontendProductToDb(currentProduct, newName.trim(), capabilities);
          await API.updateProduct(currentProduct, productData);

          initializeProductUI();
          const productBtn = document.querySelector(`.product-btn[data-product="${currentProduct}"]`);
          if (productBtn) {
            await handleProductSelection(currentProduct, productBtn, { skipSave: true, autoSelect: true });
          }
          updateCollapsedPanelTitle('Product Capabilities');
        } catch (error) {
          console.error('Failed to rename product:', error);
          productMetadata[currentProduct] = originalName;
          alert('Failed to rename product. Please try again.');
        }
      });
    }

    if (deleteProductBtn) {
      deleteProductBtn.addEventListener('click', async () => {
        if (!productEditMode || !currentProduct) {
          alert('Select a product while in Product Capabilities edit mode to delete it.');
          return;
        }

        const productName = productMetadata[currentProduct] || currentProduct;
        const confirmation = confirm(`Are you sure you want to permanently delete "${productName}"? This will remove all associated capability mappings.`);
        if (!confirmation) {
          return;
        }

        try {
          await API.deleteProduct(currentProduct);

          delete productCapabilities[currentProduct];
          delete productMetadata[currentProduct];

          clearProductHighlights();
          tempProductSelections = [];
          productDirty = false;

          currentProduct = null;

          initializeProductUI();
          updateProductControlAvailability();

          if (productEditMode) {
            const remainingKeys = Object.keys(productCapabilities);
            if (remainingKeys.length > 0) {
              const nextKey = remainingKeys[0];
              const nextBtn = document.querySelector(`.product-btn[data-product="${nextKey}"]`);
              if (nextBtn) {
                await handleProductSelection(nextKey, nextBtn, { skipSave: true, autoSelect: true });
              }
            }
          }

          updateCollapsedPanelTitle('Product Capabilities');
          console.log(`Product "${productName}" deleted successfully`);
        } catch (error) {
          console.error('Failed to delete product:', error);
          alert('Failed to delete product. Please try again.');
        }
      });
    }

    async function handleProductSelection(productKey, productBtn, options = {}) {
      const { skipSave = false, autoSelect = false } = options;
      const isActive = productBtn.classList.contains('active');

      if (isActive && !autoSelect) {
        if (productEditMode && !skipSave) {
          const saved = await persistProductChangesOrWarn('deselect-product');
          if (!saved) {
            return false;
          }
        }

        productBtn.classList.remove('active');
        currentProduct = null;
        clearProductHighlights();
        document.querySelectorAll('.product-btn').forEach(b => {
          if (b !== productBtn) {
            b.classList.remove('active');
          }
        });
        tempProductSelections = [];
        productDirty = false;
        updateProductControlAvailability();
        updateCollapsedPanelTitle('Product Capabilities');
        return true;
      }

      if (productEditMode && currentProduct && currentProduct !== productKey && !skipSave) {
        const saved = await persistProductChangesOrWarn('switch-product');
        if (!saved) {
          return false;
        }
      }

      document.querySelectorAll('.product-btn').forEach(b => b.classList.remove('active'));
      productBtn.classList.add('active');
      currentProduct = productKey;

      if (productEditMode) {
        activateProductEditingForCurrentProduct();
      } else {
        highlightProductCapabilities(productKey);
      }

      updateProductControlAvailability();
      updateCollapsedPanelTitle('Product Capabilities');
      return true;
    }

    function highlightProductCapabilities(productKey) {
      clearProductHighlights();
      const capabilities = productCapabilities[productKey] || [];
      capabilities.forEach(([role, focus]) => {
        const cell = findCell(role, focus);
        if (cell) {
          cell.classList.add('highlighted');
        }
      });
    }

    function clearProductHighlights() {
      document.querySelectorAll('td.product-edit-selected').forEach(cell => cell.classList.remove('product-edit-selected'));
      document.querySelectorAll('td.highlighted').forEach(cell => cell.classList.remove('highlighted'));
    }

    function ensureProductCapabilityState(productKey) {
      if (!productCapabilities[productKey]) {
        productCapabilities[productKey] = [];
      }
      return productCapabilities[productKey];
    }

    function addProductEditCellHandlers() {
      for (let row of table.rows) {
        for (let cell of row.cells) {
          if (cell.cellIndex === 0 || row.rowIndex === 0) continue;
          if (cell._productEditHandlerAttached) continue;
          const handler = handleProductEditCellClick;
          cell.addEventListener('click', handler);
          cell._productEditHandlerAttached = handler;
        }
      }
    }

    function removeProductEditCellHandlers() {
      for (let row of table.rows) {
        for (let cell of row.cells) {
          if (cell.cellIndex === 0 || row.rowIndex === 0) continue;
          if (!cell._productEditHandlerAttached) continue;
          cell.removeEventListener('click', cell._productEditHandlerAttached);
          delete cell._productEditHandlerAttached;
        }
      }
    }

    function activateProductEditingForCurrentProduct({ preserveSelection = false } = {}) {
      if (!productEditMode || !currentProduct) {
        return;
      }

      ensureProductCapabilityState(currentProduct);

      if (preserveSelection) {
        tempProductSelections = tempProductSelections.filter(cell => cell && cell.isConnected);
      } else {
        tempProductSelections = [];
        (productCapabilities[currentProduct] || []).forEach(([role, focus]) => {
          const cell = findCell(role, focus);
          if (cell) {
            tempProductSelections.push(cell);
          }
        });
      }

      clearProductHighlights();
      document.querySelectorAll('td.product-edit-selected').forEach(cell => cell.classList.remove('product-edit-selected'));

      tempProductSelections.forEach(cell => {
        cell.classList.add('highlighted');
        cell.classList.add('product-edit-selected');
      });

      addProductEditCellHandlers();
      productDirty = false;
      updateProductControlAvailability();
    }

    function updateProductControlAvailability() {
      const hasSelection = productEditMode && !!currentProduct;
      if (renameProductBtn) {
        renameProductBtn.disabled = !hasSelection;
      }
      if (deleteProductBtn) {
        deleteProductBtn.disabled = !hasSelection;
      }
    }

    function handleProductEditCellClick(event) {
      if (!productEditMode || !currentProduct) {
        return;
      }

      const cell = event.currentTarget;
      const index = tempProductSelections.indexOf(cell);

      if (index > -1) {
        tempProductSelections.splice(index, 1);
        cell.classList.remove('highlighted');
        cell.classList.remove('product-edit-selected');
      } else {
        tempProductSelections.push(cell);
        cell.classList.add('highlighted');
        cell.classList.add('product-edit-selected');
      }

      productDirty = true;
    }

    async function saveActiveProductChanges(reason = 'manual') {
      if (!productEditMode || !currentProduct) {
        productDirty = false;
        return;
      }

      if (!productDirty) {
        return;
      }

      const capabilities = mapCellsToWorkflowPairs(tempProductSelections);
      productCapabilities[currentProduct] = capabilities;

      const productData = DataTransform.frontendProductToDb(
        currentProduct,
        productMetadata[currentProduct] || currentProduct,
        capabilities
      );

      await API.updateProduct(currentProduct, productData);
      productDirty = false;
    }

    async function persistProductChangesOrWarn(reason = 'manual') {
      try {
        await saveActiveProductChanges(reason);
        return true;
      } catch (error) {
        console.error(`Failed to save product changes (${reason}):`, error);
        alert('Failed to save product changes. Please resolve the issue before continuing.');
        return false;
      }
    }

    function ensureProductAddButton() {
      if (!productEditMode) {
        return;
      }

      const container = document.getElementById('productButtonsContainer');
      if (!container) {
        return;
      }

      let addBtn = document.getElementById('addProductBtn');
      if (!addBtn) {
        addBtn = document.createElement('button');
        addBtn.className = 'add-btn';
        addBtn.id = 'addProductBtn';
        addBtn.textContent = '+';
        addBtn.title = 'Create a new product';
        addBtn.addEventListener('click', handleAddProduct);
      }

      if (addBtn.parentElement !== container) {
        container.insertBefore(addBtn, container.firstChild);
      } else if (container.firstChild !== addBtn) {
        container.insertBefore(addBtn, container.firstChild);
      }
    }

    function removeProductAddButton() {
      const addBtn = document.getElementById('addProductBtn');
      if (addBtn) {
        addBtn.removeEventListener('click', handleAddProduct);
        addBtn.remove();
      }
    }

    async function enterProductEditMode() {
      productEditMode = true;
      tempProductSelections = [];
      productDirty = false;

      if (productEditControls) {
        productEditControls.style.display = 'block';
      }
      if (productEditInfo) {
        productEditInfo.style.display = 'block';
      }

      if (productEditToggle) {
        productEditToggle.classList.add('active');
        productEditToggle.title = 'Exit Product Edit Mode';
      }

      ensureProductAddButton();
      addProductEditCellHandlers();
      updateProductControlAvailability();

      if (currentProduct) {
        activateProductEditingForCurrentProduct();
      } else {
        const productKeys = Object.keys(productCapabilities);
        if (productKeys.length > 0) {
          const firstKey = productKeys[0];
          const firstBtn = document.querySelector(`.product-btn[data-product="${firstKey}"]`);
          if (firstBtn) {
            await handleProductSelection(firstKey, firstBtn, { skipSave: true, autoSelect: true });
          }
        }
      }

      console.log('Entered product edit mode');
    }

    async function exitProductEditMode() {
      if (!productEditMode) {
        return true;
      }

      const saved = await persistProductChangesOrWarn('exit-product-edit');
      if (!saved) {
        return false;
      }

      productEditMode = false;
      if (productEditToggle) {
        productEditToggle.classList.remove('active');
        productEditToggle.title = 'Edit Product Capabilities';
      }

      if (productEditControls) {
        productEditControls.style.display = 'none';
      }
      if (productEditInfo) {
        productEditInfo.style.display = 'none';
      }

      removeProductAddButton();
      removeProductEditCellHandlers();
      document.querySelectorAll('td.product-edit-selected').forEach(cell => cell.classList.remove('product-edit-selected'));
      tempProductSelections = [];
      productDirty = false;
      updateProductControlAvailability();

      clearProductHighlights();
      if (currentProduct) {
        highlightProductCapabilities(currentProduct);
      }

      console.log('Exited product edit mode');
      return true;
    }

    async function handleAddProduct() {
      const productName = prompt('Enter a name for the new product:');
      if (!productName || productName.trim() === '') {
        return;
      }

      const productKey = productName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
      if (!productKey) {
        alert('Product name must include at least one alphanumeric character.');
        return;
      }

      if (productCapabilities[productKey]) {
        alert('A product with this key already exists. Please choose a different name.');
        return;
      }

      const normalizedName = productName.trim().toLowerCase();
      const existingNames = Object.values(productMetadata).map(name => (name || '').toLowerCase());
      if (existingNames.includes(normalizedName)) {
        alert('A product with this name already exists. Please choose a different name.');
        return;
      }

      try {
        const productData = DataTransform.frontendProductToDb(productKey, productName.trim(), []);
        await API.createProduct(productData);

        productCapabilities[productKey] = [];
        productMetadata[productKey] = productName.trim();

        initializeProductUI();
        const newBtn = document.querySelector(`.product-btn[data-product="${productKey}"]`);
        if (newBtn) {
          await handleProductSelection(productKey, newBtn, { skipSave: true, autoSelect: true });
        }
        updateProductControlAvailability();
        console.log(`Product "${productName}" created successfully`);
      } catch (error) {
        console.error('Failed to create product:', error);
        alert('Failed to create product. Please try again.');
      }
    }

    // ============================================================================
    // End of Product Edit Mode helpers
    // ============================================================================
    
    // ===== Initialize Application Data from Database =====
    
    // Load all data from the API when the page loads
    window.addEventListener('DOMContentLoaded', async () => {
      try {
        console.log('Loading data from database...');
        
        // Show loading indicator
        document.body.style.opacity = '0.6';
        document.body.style.pointerEvents = 'none';
        
        // Load vocabularies (dev and partner approaches) and make globally accessible
        window.cachedVocabularies = await API.getVocabularies();
        console.log('Vocabularies loaded:', window.cachedVocabularies);
        
        // Load products
        const dbProducts = await API.getProducts();
        console.log('Products loaded:', dbProducts);
        
        // Load profiles (presets)
        const dbProfiles = await API.getProfiles();
        console.log('Profiles loaded:', dbProfiles);
        
        // Load all scenarios
        const dbScenarios = await API.getScenarios();
        console.log('Scenarios loaded:', dbScenarios);
        
        // Load all workflow steps for all scenarios
        const allWorkflowSteps = [];
        for (const scenario of dbScenarios) {
          try {
            const steps = await API.getWorkflowSteps(scenario.profile_key, scenario.scenario_key);
            // Add profile and scenario keys to each step for easier processing
            steps.forEach(step => {
              step.profile_key = scenario.profile_key;
              step.scenario_key = scenario.scenario_key;
            });
            allWorkflowSteps.push(...steps);
          } catch (error) {
            console.warn(`No workflow steps for ${scenario.profile_key}:${scenario.scenario_key}`);
          }
        }
        console.log('Workflow steps loaded:', allWorkflowSteps);
        
        // Transform database data to frontend format
        const profileData = DataTransform.dbProfilesToFrontend(dbProfiles);
        Object.assign(presetFactors, profileData.presetFactors);
        Object.assign(presetMetadata, profileData.presetMetadata);
        Object.assign(presets, profileData.presets);
        
        const scenarioData = DataTransform.dbScenariosToFrontend(dbScenarios);
        Object.assign(scenarioFactors, scenarioData.scenarioFactors);
        Object.assign(scenarioMetadata, scenarioData.scenarioMetadata);
        
        const workflowData = DataTransform.dbWorkflowStepsToFrontend(allWorkflowSteps, window.cachedVocabularies);
        Object.assign(workflows, workflowData);
        
        const productData = DataTransform.dbProductsToFrontend(dbProducts, window.cachedVocabularies);
        Object.assign(productCapabilities, productData.productCapabilities);
        Object.assign(productMetadata, productData.productMetadata);
        
        console.log('Data transformation complete');
        console.log('Presets:', presets);
        console.log('Preset Factors:', presetFactors);
        console.log('Preset Metadata:', presetMetadata);
        console.log('Scenarios:', scenarioMetadata);
        console.log('Scenario Factors:', scenarioFactors);
        console.log('Workflows:', workflows);
        console.log('Products:', productCapabilities);
        console.log('Product Metadata:', productMetadata);
        
        // Initialize UIs on page load
        initializePresetUI(true); // Auto-select first preset
        initializeScenarioUI(true); // Auto-select first scenario
        initializeProductUI();
        
        // Hide loading indicator
        document.body.style.opacity = '1';
        document.body.style.pointerEvents = 'auto';
        
        console.log('Application loaded successfully from database');
      } catch (error) {
        console.error('Failed to load data from database:', error);
        document.body.style.opacity = '1';
        document.body.style.pointerEvents = 'auto';
        alert('Failed to load data from database. Please check your connection and try again.\n\nError: ' + error.message);
      }
    });
  </script>
</body>
</html>
